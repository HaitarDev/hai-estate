import {
  __assign,
  __awaiter,
  __extends,
  __generator,
  __rest,
  __spreadArray
} from "./chunk-YAVANF73.js";
import {
  Component,
  ErrorFactory,
  FirebaseError,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  base64Decode,
  createSubscribe,
  deepEqual,
  extractQuerystring,
  getApp,
  getModularInstance,
  getUA,
  isBrowserExtension,
  isEmpty,
  isIE,
  isMobileCordova,
  isReactNative,
  querystring,
  querystringDecode,
  registerVersion
} from "./chunk-5BMZSUNJ.js";
import "./chunk-LNEMQRCO.js";

// node_modules/@firebase/auth/dist/cordova/popup_redirect-106f885f.js
var STORAGE_AVAILABLE_KEY = "__sak";
function _allSettled(promises) {
  var _this = this;
  return Promise.all(promises.map(function(promise) {
    return __awaiter(_this, void 0, void 0, function() {
      var value, reason_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, promise];
          case 1:
            value = _a2.sent();
            return [2, {
              fulfilled: true,
              value
            }];
          case 2:
            reason_1 = _a2.sent();
            return [2, {
              fulfilled: false,
              reason: reason_1
            }];
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }));
}
var Receiver = (
  /** @class */
  function() {
    function Receiver2(eventTarget) {
      this.eventTarget = eventTarget;
      this.handlersMap = {};
      this.boundEventHandler = this.handleEvent.bind(this);
    }
    Receiver2._getInstance = function(eventTarget) {
      var existingInstance = this.receivers.find(function(receiver) {
        return receiver.isListeningto(eventTarget);
      });
      if (existingInstance) {
        return existingInstance;
      }
      var newInstance = new Receiver2(eventTarget);
      this.receivers.push(newInstance);
      return newInstance;
    };
    Receiver2.prototype.isListeningto = function(eventTarget) {
      return this.eventTarget === eventTarget;
    };
    Receiver2.prototype.handleEvent = function(event) {
      return __awaiter(this, void 0, void 0, function() {
        var messageEvent, _a2, eventId, eventType, data, handlers, promises, response;
        var _this = this;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              messageEvent = event;
              _a2 = messageEvent.data, eventId = _a2.eventId, eventType = _a2.eventType, data = _a2.data;
              handlers = this.handlersMap[eventType];
              if (!(handlers === null || handlers === void 0 ? void 0 : handlers.size)) {
                return [
                  2
                  /*return*/
                ];
              }
              messageEvent.ports[0].postMessage({
                status: "ack",
                eventId,
                eventType
              });
              promises = Array.from(handlers).map(function(handler) {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_a3) {
                    return [2, handler(messageEvent.origin, data)];
                  });
                });
              });
              return [4, _allSettled(promises)];
            case 1:
              response = _b.sent();
              messageEvent.ports[0].postMessage({
                status: "done",
                eventId,
                eventType,
                response
              });
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Receiver2.prototype._subscribe = function(eventType, eventHandler) {
      if (Object.keys(this.handlersMap).length === 0) {
        this.eventTarget.addEventListener("message", this.boundEventHandler);
      }
      if (!this.handlersMap[eventType]) {
        this.handlersMap[eventType] = /* @__PURE__ */ new Set();
      }
      this.handlersMap[eventType].add(eventHandler);
    };
    Receiver2.prototype._unsubscribe = function(eventType, eventHandler) {
      if (this.handlersMap[eventType] && eventHandler) {
        this.handlersMap[eventType].delete(eventHandler);
      }
      if (!eventHandler || this.handlersMap[eventType].size === 0) {
        delete this.handlersMap[eventType];
      }
      if (Object.keys(this.handlersMap).length === 0) {
        this.eventTarget.removeEventListener("message", this.boundEventHandler);
      }
    };
    Receiver2.receivers = [];
    return Receiver2;
  }()
);
function _generateEventId(prefix, digits) {
  if (prefix === void 0) {
    prefix = "";
  }
  if (digits === void 0) {
    digits = 10;
  }
  var random = "";
  for (var i = 0; i < digits; i++) {
    random += Math.floor(Math.random() * 10);
  }
  return prefix + random;
}
var Sender = (
  /** @class */
  function() {
    function Sender2(target) {
      this.target = target;
      this.handlers = /* @__PURE__ */ new Set();
    }
    Sender2.prototype.removeMessageHandler = function(handler) {
      if (handler.messageChannel) {
        handler.messageChannel.port1.removeEventListener("message", handler.onMessage);
        handler.messageChannel.port1.close();
      }
      this.handlers.delete(handler);
    };
    Sender2.prototype._send = function(eventType, data, timeout) {
      if (timeout === void 0) {
        timeout = 50;
      }
      return __awaiter(this, void 0, void 0, function() {
        var messageChannel, completionTimer, handler;
        var _this = this;
        return __generator(this, function(_a2) {
          messageChannel = typeof MessageChannel !== "undefined" ? new MessageChannel() : null;
          if (!messageChannel) {
            throw new Error(
              "connection_unavailable"
              /* _MessageError.CONNECTION_UNAVAILABLE */
            );
          }
          return [2, new Promise(function(resolve, reject) {
            var eventId = _generateEventId("", 20);
            messageChannel.port1.start();
            var ackTimer = setTimeout(function() {
              reject(new Error(
                "unsupported_event"
                /* _MessageError.UNSUPPORTED_EVENT */
              ));
            }, timeout);
            handler = {
              messageChannel,
              onMessage: function(event) {
                var messageEvent = event;
                if (messageEvent.data.eventId !== eventId) {
                  return;
                }
                switch (messageEvent.data.status) {
                  case "ack":
                    clearTimeout(ackTimer);
                    completionTimer = setTimeout(
                      function() {
                        reject(new Error(
                          "timeout"
                          /* _MessageError.TIMEOUT */
                        ));
                      },
                      3e3
                      /* _TimeoutDuration.COMPLETION */
                    );
                    break;
                  case "done":
                    clearTimeout(completionTimer);
                    resolve(messageEvent.data.response);
                    break;
                  default:
                    clearTimeout(ackTimer);
                    clearTimeout(completionTimer);
                    reject(new Error(
                      "invalid_response"
                      /* _MessageError.INVALID_RESPONSE */
                    ));
                    break;
                }
              }
            };
            _this.handlers.add(handler);
            messageChannel.port1.addEventListener("message", handler.onMessage);
            _this.target.postMessage({
              eventType,
              eventId,
              data
            }, [messageChannel.port2]);
          }).finally(function() {
            if (handler) {
              _this.removeMessageHandler(handler);
            }
          })];
        });
      });
    };
    return Sender2;
  }()
);
function _window() {
  return window;
}
function _isWorker() {
  return typeof _window()["WorkerGlobalScope"] !== "undefined" && typeof _window()["importScripts"] === "function";
}
function _getActiveServiceWorker() {
  return __awaiter(this, void 0, void 0, function() {
    var registration;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          if (!(navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker)) {
            return [2, null];
          }
          _b.label = 1;
        case 1:
          _b.trys.push([1, 3, , 4]);
          return [4, navigator.serviceWorker.ready];
        case 2:
          registration = _b.sent();
          return [2, registration.active];
        case 3:
          _b.sent();
          return [2, null];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function _getServiceWorkerController() {
  var _a2;
  return ((_a2 = navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker) === null || _a2 === void 0 ? void 0 : _a2.controller) || null;
}
function _getWorkerGlobalScope() {
  return _isWorker() ? self : null;
}
var DB_NAME = "firebaseLocalStorageDb";
var DB_VERSION = 1;
var DB_OBJECTSTORE_NAME = "firebaseLocalStorage";
var DB_DATA_KEYPATH = "fbase_key";
var DBPromise = (
  /** @class */
  function() {
    function DBPromise2(request) {
      this.request = request;
    }
    DBPromise2.prototype.toPromise = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        _this.request.addEventListener("success", function() {
          resolve(_this.request.result);
        });
        _this.request.addEventListener("error", function() {
          reject(_this.request.error);
        });
      });
    };
    return DBPromise2;
  }()
);
function getObjectStore(db, isReadWrite) {
  return db.transaction([DB_OBJECTSTORE_NAME], isReadWrite ? "readwrite" : "readonly").objectStore(DB_OBJECTSTORE_NAME);
}
function _deleteDatabase() {
  var request = indexedDB.deleteDatabase(DB_NAME);
  return new DBPromise(request).toPromise();
}
function _openDatabase() {
  var _this = this;
  var request = indexedDB.open(DB_NAME, DB_VERSION);
  return new Promise(function(resolve, reject) {
    request.addEventListener("error", function() {
      reject(request.error);
    });
    request.addEventListener("upgradeneeded", function() {
      var db = request.result;
      try {
        db.createObjectStore(DB_OBJECTSTORE_NAME, { keyPath: DB_DATA_KEYPATH });
      } catch (e) {
        reject(e);
      }
    });
    request.addEventListener("success", function() {
      return __awaiter(_this, void 0, void 0, function() {
        var db, _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              db = request.result;
              if (!!db.objectStoreNames.contains(DB_OBJECTSTORE_NAME))
                return [3, 3];
              db.close();
              return [4, _deleteDatabase()];
            case 1:
              _b.sent();
              _a2 = resolve;
              return [4, _openDatabase()];
            case 2:
              _a2.apply(void 0, [_b.sent()]);
              return [3, 4];
            case 3:
              resolve(db);
              _b.label = 4;
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    });
  });
}
function _putObject(db, key, value) {
  return __awaiter(this, void 0, void 0, function() {
    var request;
    var _a2;
    return __generator(this, function(_b) {
      request = getObjectStore(db, true).put((_a2 = {}, _a2[DB_DATA_KEYPATH] = key, _a2.value = value, _a2));
      return [2, new DBPromise(request).toPromise()];
    });
  });
}
function getObject(db, key) {
  return __awaiter(this, void 0, void 0, function() {
    var request, data;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          request = getObjectStore(db, false).get(key);
          return [4, new DBPromise(request).toPromise()];
        case 1:
          data = _a2.sent();
          return [2, data === void 0 ? null : data.value];
      }
    });
  });
}
function _deleteObject(db, key) {
  var request = getObjectStore(db, true).delete(key);
  return new DBPromise(request).toPromise();
}
var _POLLING_INTERVAL_MS$1 = 800;
var _TRANSACTION_RETRY_COUNT = 3;
var IndexedDBLocalPersistence = (
  /** @class */
  function() {
    function IndexedDBLocalPersistence2() {
      this.type = "LOCAL";
      this._shouldAllowMigration = true;
      this.listeners = {};
      this.localCache = {};
      this.pollTimer = null;
      this.pendingWrites = 0;
      this.receiver = null;
      this.sender = null;
      this.serviceWorkerReceiverAvailable = false;
      this.activeServiceWorker = null;
      this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(function() {
      }, function() {
      });
    }
    IndexedDBLocalPersistence2.prototype._openDb = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (this.db) {
                return [2, this.db];
              }
              _a2 = this;
              return [4, _openDatabase()];
            case 1:
              _a2.db = _b.sent();
              return [2, this.db];
          }
        });
      });
    };
    IndexedDBLocalPersistence2.prototype._withRetries = function(op) {
      return __awaiter(this, void 0, void 0, function() {
        var numAttempts, db, e_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              numAttempts = 0;
              _a2.label = 1;
            case 1:
              _a2.label = 2;
            case 2:
              _a2.trys.push([2, 5, , 6]);
              return [4, this._openDb()];
            case 3:
              db = _a2.sent();
              return [4, op(db)];
            case 4:
              return [2, _a2.sent()];
            case 5:
              e_1 = _a2.sent();
              if (numAttempts++ > _TRANSACTION_RETRY_COUNT) {
                throw e_1;
              }
              if (this.db) {
                this.db.close();
                this.db = void 0;
              }
              return [3, 6];
            case 6:
              return [3, 1];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    IndexedDBLocalPersistence2.prototype.initializeServiceWorkerMessaging = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          return [2, _isWorker() ? this.initializeReceiver() : this.initializeSender()];
        });
      });
    };
    IndexedDBLocalPersistence2.prototype.initializeReceiver = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _this = this;
        return __generator(this, function(_a2) {
          this.receiver = Receiver._getInstance(_getWorkerGlobalScope());
          this.receiver._subscribe("keyChanged", function(_origin, data) {
            return __awaiter(_this, void 0, void 0, function() {
              var keys;
              return __generator(this, function(_a3) {
                switch (_a3.label) {
                  case 0:
                    return [4, this._poll()];
                  case 1:
                    keys = _a3.sent();
                    return [2, {
                      keyProcessed: keys.includes(data.key)
                    }];
                }
              });
            });
          });
          this.receiver._subscribe("ping", function(_origin, _data) {
            return __awaiter(_this, void 0, void 0, function() {
              return __generator(this, function(_a3) {
                return [2, [
                  "keyChanged"
                  /* _EventType.KEY_CHANGED */
                ]];
              });
            });
          });
          return [
            2
            /*return*/
          ];
        });
      });
    };
    IndexedDBLocalPersistence2.prototype.initializeSender = function() {
      var _a2, _b;
      return __awaiter(this, void 0, void 0, function() {
        var _c, results;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _c = this;
              return [4, _getActiveServiceWorker()];
            case 1:
              _c.activeServiceWorker = _d.sent();
              if (!this.activeServiceWorker) {
                return [
                  2
                  /*return*/
                ];
              }
              this.sender = new Sender(this.activeServiceWorker);
              return [4, this.sender._send(
                "ping",
                {},
                800
                /* _TimeoutDuration.LONG_ACK */
              )];
            case 2:
              results = _d.sent();
              if (!results) {
                return [
                  2
                  /*return*/
                ];
              }
              if (((_a2 = results[0]) === null || _a2 === void 0 ? void 0 : _a2.fulfilled) && ((_b = results[0]) === null || _b === void 0 ? void 0 : _b.value.includes(
                "keyChanged"
                /* _EventType.KEY_CHANGED */
              ))) {
                this.serviceWorkerReceiverAvailable = true;
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    IndexedDBLocalPersistence2.prototype.notifyServiceWorker = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!this.sender || !this.activeServiceWorker || _getServiceWorkerController() !== this.activeServiceWorker) {
                return [
                  2
                  /*return*/
                ];
              }
              _b.label = 1;
            case 1:
              _b.trys.push([1, 3, , 4]);
              return [4, this.sender._send(
                "keyChanged",
                { key },
                // Use long timeout if receiver has previously responded to a ping from us.
                this.serviceWorkerReceiverAvailable ? 800 : 50
                /* _TimeoutDuration.ACK */
              )];
            case 2:
              _b.sent();
              return [3, 4];
            case 3:
              _b.sent();
              return [3, 4];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    IndexedDBLocalPersistence2.prototype._isAvailable = function() {
      return __awaiter(this, void 0, void 0, function() {
        var db;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 4, , 5]);
              if (!indexedDB) {
                return [2, false];
              }
              return [4, _openDatabase()];
            case 1:
              db = _b.sent();
              return [4, _putObject(db, STORAGE_AVAILABLE_KEY, "1")];
            case 2:
              _b.sent();
              return [4, _deleteObject(db, STORAGE_AVAILABLE_KEY)];
            case 3:
              _b.sent();
              return [2, true];
            case 4:
              _b.sent();
              return [3, 5];
            case 5:
              return [2, false];
          }
        });
      });
    };
    IndexedDBLocalPersistence2.prototype._withPendingWrite = function(write) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.pendingWrites++;
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, , 3, 4]);
              return [4, write()];
            case 2:
              _a2.sent();
              return [3, 4];
            case 3:
              this.pendingWrites--;
              return [
                7
                /*endfinally*/
              ];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    IndexedDBLocalPersistence2.prototype._set = function(key, value) {
      return __awaiter(this, void 0, void 0, function() {
        var _this = this;
        return __generator(this, function(_a2) {
          return [2, this._withPendingWrite(function() {
            return __awaiter(_this, void 0, void 0, function() {
              return __generator(this, function(_a3) {
                switch (_a3.label) {
                  case 0:
                    return [4, this._withRetries(function(db) {
                      return _putObject(db, key, value);
                    })];
                  case 1:
                    _a3.sent();
                    this.localCache[key] = value;
                    return [2, this.notifyServiceWorker(key)];
                }
              });
            });
          })];
        });
      });
    };
    IndexedDBLocalPersistence2.prototype._get = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        var obj;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this._withRetries(function(db) {
                return getObject(db, key);
              })];
            case 1:
              obj = _a2.sent();
              this.localCache[key] = obj;
              return [2, obj];
          }
        });
      });
    };
    IndexedDBLocalPersistence2.prototype._remove = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        var _this = this;
        return __generator(this, function(_a2) {
          return [2, this._withPendingWrite(function() {
            return __awaiter(_this, void 0, void 0, function() {
              return __generator(this, function(_a3) {
                switch (_a3.label) {
                  case 0:
                    return [4, this._withRetries(function(db) {
                      return _deleteObject(db, key);
                    })];
                  case 1:
                    _a3.sent();
                    delete this.localCache[key];
                    return [2, this.notifyServiceWorker(key)];
                }
              });
            });
          })];
        });
      });
    };
    IndexedDBLocalPersistence2.prototype._poll = function() {
      return __awaiter(this, void 0, void 0, function() {
        var result, keys, keysInResult, _i, result_1, _a2, key, value, _b, _c, localKey;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, this._withRetries(function(db) {
                var getAllRequest = getObjectStore(db, false).getAll();
                return new DBPromise(getAllRequest).toPromise();
              })];
            case 1:
              result = _d.sent();
              if (!result) {
                return [2, []];
              }
              if (this.pendingWrites !== 0) {
                return [2, []];
              }
              keys = [];
              keysInResult = /* @__PURE__ */ new Set();
              if (result.length !== 0) {
                for (_i = 0, result_1 = result; _i < result_1.length; _i++) {
                  _a2 = result_1[_i], key = _a2.fbase_key, value = _a2.value;
                  keysInResult.add(key);
                  if (JSON.stringify(this.localCache[key]) !== JSON.stringify(value)) {
                    this.notifyListeners(key, value);
                    keys.push(key);
                  }
                }
              }
              for (_b = 0, _c = Object.keys(this.localCache); _b < _c.length; _b++) {
                localKey = _c[_b];
                if (this.localCache[localKey] && !keysInResult.has(localKey)) {
                  this.notifyListeners(localKey, null);
                  keys.push(localKey);
                }
              }
              return [2, keys];
          }
        });
      });
    };
    IndexedDBLocalPersistence2.prototype.notifyListeners = function(key, newValue) {
      this.localCache[key] = newValue;
      var listeners = this.listeners[key];
      if (listeners) {
        for (var _i = 0, _a2 = Array.from(listeners); _i < _a2.length; _i++) {
          var listener = _a2[_i];
          listener(newValue);
        }
      }
    };
    IndexedDBLocalPersistence2.prototype.startPolling = function() {
      var _this = this;
      this.stopPolling();
      this.pollTimer = setInterval(function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            return [2, this._poll()];
          });
        });
      }, _POLLING_INTERVAL_MS$1);
    };
    IndexedDBLocalPersistence2.prototype.stopPolling = function() {
      if (this.pollTimer) {
        clearInterval(this.pollTimer);
        this.pollTimer = null;
      }
    };
    IndexedDBLocalPersistence2.prototype._addListener = function(key, listener) {
      if (Object.keys(this.listeners).length === 0) {
        this.startPolling();
      }
      if (!this.listeners[key]) {
        this.listeners[key] = /* @__PURE__ */ new Set();
        void this._get(key);
      }
      this.listeners[key].add(listener);
    };
    IndexedDBLocalPersistence2.prototype._removeListener = function(key, listener) {
      if (this.listeners[key]) {
        this.listeners[key].delete(listener);
        if (this.listeners[key].size === 0) {
          delete this.listeners[key];
        }
      }
      if (Object.keys(this.listeners).length === 0) {
        this.stopPolling();
      }
    };
    IndexedDBLocalPersistence2.type = "LOCAL";
    return IndexedDBLocalPersistence2;
  }()
);
var indexedDBLocalPersistence = IndexedDBLocalPersistence;
function _debugErrorMap() {
  var _a2;
  return _a2 = {}, _a2[
    "admin-restricted-operation"
    /* AuthErrorCode.ADMIN_ONLY_OPERATION */
  ] = "This operation is restricted to administrators only.", _a2[
    "argument-error"
    /* AuthErrorCode.ARGUMENT_ERROR */
  ] = "", _a2[
    "app-not-authorized"
    /* AuthErrorCode.APP_NOT_AUTHORIZED */
  ] = "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.", _a2[
    "app-not-installed"
    /* AuthErrorCode.APP_NOT_INSTALLED */
  ] = "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.", _a2[
    "captcha-check-failed"
    /* AuthErrorCode.CAPTCHA_CHECK_FAILED */
  ] = "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.", _a2[
    "code-expired"
    /* AuthErrorCode.CODE_EXPIRED */
  ] = "The SMS code has expired. Please re-send the verification code to try again.", _a2[
    "cordova-not-ready"
    /* AuthErrorCode.CORDOVA_NOT_READY */
  ] = "Cordova framework is not ready.", _a2[
    "cors-unsupported"
    /* AuthErrorCode.CORS_UNSUPPORTED */
  ] = "This browser is not supported.", _a2[
    "credential-already-in-use"
    /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */
  ] = "This credential is already associated with a different user account.", _a2[
    "custom-token-mismatch"
    /* AuthErrorCode.CREDENTIAL_MISMATCH */
  ] = "The custom token corresponds to a different audience.", _a2[
    "requires-recent-login"
    /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */
  ] = "This operation is sensitive and requires recent authentication. Log in again before retrying this request.", _a2[
    "dependent-sdk-initialized-before-auth"
    /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */
  ] = "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.", _a2[
    "dynamic-link-not-activated"
    /* AuthErrorCode.DYNAMIC_LINK_NOT_ACTIVATED */
  ] = "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.", _a2[
    "email-change-needs-verification"
    /* AuthErrorCode.EMAIL_CHANGE_NEEDS_VERIFICATION */
  ] = "Multi-factor users must always have a verified email.", _a2[
    "email-already-in-use"
    /* AuthErrorCode.EMAIL_EXISTS */
  ] = "The email address is already in use by another account.", _a2[
    "emulator-config-failed"
    /* AuthErrorCode.EMULATOR_CONFIG_FAILED */
  ] = 'Auth instance has already been used to make a network call. Auth can no longer be configured to use the emulator. Try calling "connectAuthEmulator()" sooner.', _a2[
    "expired-action-code"
    /* AuthErrorCode.EXPIRED_OOB_CODE */
  ] = "The action code has expired.", _a2[
    "cancelled-popup-request"
    /* AuthErrorCode.EXPIRED_POPUP_REQUEST */
  ] = "This operation has been cancelled due to another conflicting popup being opened.", _a2[
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ] = "An internal AuthError has occurred.", _a2[
    "invalid-app-credential"
    /* AuthErrorCode.INVALID_APP_CREDENTIAL */
  ] = "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.", _a2[
    "invalid-app-id"
    /* AuthErrorCode.INVALID_APP_ID */
  ] = "The mobile app identifier is not registed for the current project.", _a2[
    "invalid-user-token"
    /* AuthErrorCode.INVALID_AUTH */
  ] = "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.", _a2[
    "invalid-auth-event"
    /* AuthErrorCode.INVALID_AUTH_EVENT */
  ] = "An internal AuthError has occurred.", _a2[
    "invalid-verification-code"
    /* AuthErrorCode.INVALID_CODE */
  ] = "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure to use the verification code provided by the user.", _a2[
    "invalid-continue-uri"
    /* AuthErrorCode.INVALID_CONTINUE_URI */
  ] = "The continue URL provided in the request is invalid.", _a2[
    "invalid-cordova-configuration"
    /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */
  ] = "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.", _a2[
    "invalid-custom-token"
    /* AuthErrorCode.INVALID_CUSTOM_TOKEN */
  ] = "The custom token format is incorrect. Please check the documentation.", _a2[
    "invalid-dynamic-link-domain"
    /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */
  ] = "The provided dynamic link domain is not configured or authorized for the current project.", _a2[
    "invalid-email"
    /* AuthErrorCode.INVALID_EMAIL */
  ] = "The email address is badly formatted.", _a2[
    "invalid-emulator-scheme"
    /* AuthErrorCode.INVALID_EMULATOR_SCHEME */
  ] = "Emulator URL must start with a valid scheme (http:// or https://).", _a2[
    "invalid-api-key"
    /* AuthErrorCode.INVALID_API_KEY */
  ] = "Your API key is invalid, please check you have copied it correctly.", _a2[
    "invalid-cert-hash"
    /* AuthErrorCode.INVALID_CERT_HASH */
  ] = "The SHA-1 certificate hash provided is invalid.", _a2[
    "invalid-credential"
    /* AuthErrorCode.INVALID_CREDENTIAL */
  ] = "The supplied auth credential is incorrect, malformed or has expired.", _a2[
    "invalid-message-payload"
    /* AuthErrorCode.INVALID_MESSAGE_PAYLOAD */
  ] = "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.", _a2[
    "invalid-multi-factor-session"
    /* AuthErrorCode.INVALID_MFA_SESSION */
  ] = "The request does not contain a valid proof of first factor successful sign-in.", _a2[
    "invalid-oauth-provider"
    /* AuthErrorCode.INVALID_OAUTH_PROVIDER */
  ] = "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.", _a2[
    "invalid-oauth-client-id"
    /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */
  ] = "The OAuth client ID provided is either invalid or does not match the specified API key.", _a2[
    "unauthorized-domain"
    /* AuthErrorCode.INVALID_ORIGIN */
  ] = "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.", _a2[
    "invalid-action-code"
    /* AuthErrorCode.INVALID_OOB_CODE */
  ] = "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.", _a2[
    "wrong-password"
    /* AuthErrorCode.INVALID_PASSWORD */
  ] = "The password is invalid or the user does not have a password.", _a2[
    "invalid-persistence-type"
    /* AuthErrorCode.INVALID_PERSISTENCE */
  ] = "The specified persistence type is invalid. It can only be local, session or none.", _a2[
    "invalid-phone-number"
    /* AuthErrorCode.INVALID_PHONE_NUMBER */
  ] = "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].", _a2[
    "invalid-provider-id"
    /* AuthErrorCode.INVALID_PROVIDER_ID */
  ] = "The specified provider ID is invalid.", _a2[
    "invalid-recipient-email"
    /* AuthErrorCode.INVALID_RECIPIENT_EMAIL */
  ] = "The email corresponding to this action failed to send as the provided recipient email address is invalid.", _a2[
    "invalid-sender"
    /* AuthErrorCode.INVALID_SENDER */
  ] = "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.", _a2[
    "invalid-verification-id"
    /* AuthErrorCode.INVALID_SESSION_INFO */
  ] = "The verification ID used to create the phone auth credential is invalid.", _a2[
    "invalid-tenant-id"
    /* AuthErrorCode.INVALID_TENANT_ID */
  ] = "The Auth instance's tenant ID is invalid.", _a2[
    "login-blocked"
    /* AuthErrorCode.LOGIN_BLOCKED */
  ] = "Login blocked by user-provided method: {$originalMessage}", _a2[
    "missing-android-pkg-name"
    /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */
  ] = "An Android Package Name must be provided if the Android App is required to be installed.", _a2[
    "auth-domain-config-required"
    /* AuthErrorCode.MISSING_AUTH_DOMAIN */
  ] = "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.", _a2[
    "missing-app-credential"
    /* AuthErrorCode.MISSING_APP_CREDENTIAL */
  ] = "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.", _a2[
    "missing-verification-code"
    /* AuthErrorCode.MISSING_CODE */
  ] = "The phone auth credential was created with an empty SMS verification code.", _a2[
    "missing-continue-uri"
    /* AuthErrorCode.MISSING_CONTINUE_URI */
  ] = "A continue URL must be provided in the request.", _a2[
    "missing-iframe-start"
    /* AuthErrorCode.MISSING_IFRAME_START */
  ] = "An internal AuthError has occurred.", _a2[
    "missing-ios-bundle-id"
    /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */
  ] = "An iOS Bundle ID must be provided if an App Store ID is provided.", _a2[
    "missing-or-invalid-nonce"
    /* AuthErrorCode.MISSING_OR_INVALID_NONCE */
  ] = "The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.", _a2[
    "missing-password"
    /* AuthErrorCode.MISSING_PASSWORD */
  ] = "A non-empty password must be provided", _a2[
    "missing-multi-factor-info"
    /* AuthErrorCode.MISSING_MFA_INFO */
  ] = "No second factor identifier is provided.", _a2[
    "missing-multi-factor-session"
    /* AuthErrorCode.MISSING_MFA_SESSION */
  ] = "The request is missing proof of first factor successful sign-in.", _a2[
    "missing-phone-number"
    /* AuthErrorCode.MISSING_PHONE_NUMBER */
  ] = "To send verification codes, provide a phone number for the recipient.", _a2[
    "missing-verification-id"
    /* AuthErrorCode.MISSING_SESSION_INFO */
  ] = "The phone auth credential was created with an empty verification ID.", _a2[
    "app-deleted"
    /* AuthErrorCode.MODULE_DESTROYED */
  ] = "This instance of FirebaseApp has been deleted.", _a2[
    "multi-factor-info-not-found"
    /* AuthErrorCode.MFA_INFO_NOT_FOUND */
  ] = "The user does not have a second factor matching the identifier provided.", _a2[
    "multi-factor-auth-required"
    /* AuthErrorCode.MFA_REQUIRED */
  ] = "Proof of ownership of a second factor is required to complete sign-in.", _a2[
    "account-exists-with-different-credential"
    /* AuthErrorCode.NEED_CONFIRMATION */
  ] = "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.", _a2[
    "network-request-failed"
    /* AuthErrorCode.NETWORK_REQUEST_FAILED */
  ] = "A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.", _a2[
    "no-auth-event"
    /* AuthErrorCode.NO_AUTH_EVENT */
  ] = "An internal AuthError has occurred.", _a2[
    "no-such-provider"
    /* AuthErrorCode.NO_SUCH_PROVIDER */
  ] = "User was not linked to an account with the given provider.", _a2[
    "null-user"
    /* AuthErrorCode.NULL_USER */
  ] = "A null user object was provided as the argument for an operation which requires a non-null user object.", _a2[
    "operation-not-allowed"
    /* AuthErrorCode.OPERATION_NOT_ALLOWED */
  ] = "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.", _a2[
    "operation-not-supported-in-this-environment"
    /* AuthErrorCode.OPERATION_NOT_SUPPORTED */
  ] = 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.', _a2[
    "popup-blocked"
    /* AuthErrorCode.POPUP_BLOCKED */
  ] = "Unable to establish a connection with the popup. It may have been blocked by the browser.", _a2[
    "popup-closed-by-user"
    /* AuthErrorCode.POPUP_CLOSED_BY_USER */
  ] = "The popup has been closed by the user before finalizing the operation.", _a2[
    "provider-already-linked"
    /* AuthErrorCode.PROVIDER_ALREADY_LINKED */
  ] = "User can only be linked to one identity for the given provider.", _a2[
    "quota-exceeded"
    /* AuthErrorCode.QUOTA_EXCEEDED */
  ] = "The project's quota for this operation has been exceeded.", _a2[
    "redirect-cancelled-by-user"
    /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */
  ] = "The redirect operation has been cancelled by the user before finalizing.", _a2[
    "redirect-operation-pending"
    /* AuthErrorCode.REDIRECT_OPERATION_PENDING */
  ] = "A redirect sign-in operation is already pending.", _a2[
    "rejected-credential"
    /* AuthErrorCode.REJECTED_CREDENTIAL */
  ] = "The request contains malformed or mismatching credentials.", _a2[
    "second-factor-already-in-use"
    /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */
  ] = "The second factor is already enrolled on this account.", _a2[
    "maximum-second-factor-count-exceeded"
    /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */
  ] = "The maximum allowed number of second factors on a user has been exceeded.", _a2[
    "tenant-id-mismatch"
    /* AuthErrorCode.TENANT_ID_MISMATCH */
  ] = "The provided tenant ID does not match the Auth instance's tenant ID", _a2[
    "timeout"
    /* AuthErrorCode.TIMEOUT */
  ] = "The operation has timed out.", _a2[
    "user-token-expired"
    /* AuthErrorCode.TOKEN_EXPIRED */
  ] = "The user's credential is no longer valid. The user must sign in again.", _a2[
    "too-many-requests"
    /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */
  ] = "We have blocked all requests from this device due to unusual activity. Try again later.", _a2[
    "unauthorized-continue-uri"
    /* AuthErrorCode.UNAUTHORIZED_DOMAIN */
  ] = "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.", _a2[
    "unsupported-first-factor"
    /* AuthErrorCode.UNSUPPORTED_FIRST_FACTOR */
  ] = "Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.", _a2[
    "unsupported-persistence-type"
    /* AuthErrorCode.UNSUPPORTED_PERSISTENCE */
  ] = "The current environment does not support the specified persistence type.", _a2[
    "unsupported-tenant-operation"
    /* AuthErrorCode.UNSUPPORTED_TENANT_OPERATION */
  ] = "This operation is not supported in a multi-tenant context.", _a2[
    "unverified-email"
    /* AuthErrorCode.UNVERIFIED_EMAIL */
  ] = "The operation requires a verified email.", _a2[
    "user-cancelled"
    /* AuthErrorCode.USER_CANCELLED */
  ] = "The user did not grant your application the permissions it requested.", _a2[
    "user-not-found"
    /* AuthErrorCode.USER_DELETED */
  ] = "There is no user record corresponding to this identifier. The user may have been deleted.", _a2[
    "user-disabled"
    /* AuthErrorCode.USER_DISABLED */
  ] = "The user account has been disabled by an administrator.", _a2[
    "user-mismatch"
    /* AuthErrorCode.USER_MISMATCH */
  ] = "The supplied credentials do not correspond to the previously signed in user.", _a2[
    "user-signed-out"
    /* AuthErrorCode.USER_SIGNED_OUT */
  ] = "", _a2[
    "weak-password"
    /* AuthErrorCode.WEAK_PASSWORD */
  ] = "The password must be 6 characters long or more.", _a2[
    "web-storage-unsupported"
    /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */
  ] = "This browser is not supported or 3rd party cookies and data may be disabled.", _a2[
    "already-initialized"
    /* AuthErrorCode.ALREADY_INITIALIZED */
  ] = "initializeAuth() has already been called with different options. To avoid this error, call initializeAuth() with the same options as when it was originally called, or call getAuth() to return the already initialized instance.", _a2[
    "missing-recaptcha-token"
    /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */
  ] = "The reCAPTCHA token is missing when sending request to the backend.", _a2[
    "invalid-recaptcha-token"
    /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */
  ] = "The reCAPTCHA token is invalid when sending request to the backend.", _a2[
    "invalid-recaptcha-action"
    /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */
  ] = "The reCAPTCHA action is invalid when sending request to the backend.", _a2[
    "recaptcha-not-enabled"
    /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */
  ] = "reCAPTCHA Enterprise integration is not enabled for this project.", _a2[
    "missing-client-type"
    /* AuthErrorCode.MISSING_CLIENT_TYPE */
  ] = "The reCAPTCHA client type is missing when sending request to the backend.", _a2[
    "missing-recaptcha-version"
    /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */
  ] = "The reCAPTCHA version is missing when sending request to the backend.", _a2[
    "invalid-req-type"
    /* AuthErrorCode.INVALID_REQ_TYPE */
  ] = "Invalid request parameters.", _a2[
    "invalid-recaptcha-version"
    /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */
  ] = "The reCAPTCHA version is invalid when sending request to the backend.", _a2[
    "unsupported-password-policy-schema-version"
    /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */
  ] = "The password policy received from the backend uses a schema version that is not supported by this version of the Firebase SDK.", _a2[
    "password-does-not-meet-requirements"
    /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */
  ] = "The password does not meet the requirements.", _a2;
}
function _prodErrorMap() {
  var _a2;
  return _a2 = {}, _a2[
    "dependent-sdk-initialized-before-auth"
    /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */
  ] = "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.", _a2;
}
var debugErrorMap = _debugErrorMap;
var prodErrorMap = _prodErrorMap;
var _DEFAULT_AUTH_ERROR_FACTORY = new ErrorFactory("auth", "Firebase", _prodErrorMap());
var AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {
  ADMIN_ONLY_OPERATION: "auth/admin-restricted-operation",
  ARGUMENT_ERROR: "auth/argument-error",
  APP_NOT_AUTHORIZED: "auth/app-not-authorized",
  APP_NOT_INSTALLED: "auth/app-not-installed",
  CAPTCHA_CHECK_FAILED: "auth/captcha-check-failed",
  CODE_EXPIRED: "auth/code-expired",
  CORDOVA_NOT_READY: "auth/cordova-not-ready",
  CORS_UNSUPPORTED: "auth/cors-unsupported",
  CREDENTIAL_ALREADY_IN_USE: "auth/credential-already-in-use",
  CREDENTIAL_MISMATCH: "auth/custom-token-mismatch",
  CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "auth/requires-recent-login",
  DEPENDENT_SDK_INIT_BEFORE_AUTH: "auth/dependent-sdk-initialized-before-auth",
  DYNAMIC_LINK_NOT_ACTIVATED: "auth/dynamic-link-not-activated",
  EMAIL_CHANGE_NEEDS_VERIFICATION: "auth/email-change-needs-verification",
  EMAIL_EXISTS: "auth/email-already-in-use",
  EMULATOR_CONFIG_FAILED: "auth/emulator-config-failed",
  EXPIRED_OOB_CODE: "auth/expired-action-code",
  EXPIRED_POPUP_REQUEST: "auth/cancelled-popup-request",
  INTERNAL_ERROR: "auth/internal-error",
  INVALID_API_KEY: "auth/invalid-api-key",
  INVALID_APP_CREDENTIAL: "auth/invalid-app-credential",
  INVALID_APP_ID: "auth/invalid-app-id",
  INVALID_AUTH: "auth/invalid-user-token",
  INVALID_AUTH_EVENT: "auth/invalid-auth-event",
  INVALID_CERT_HASH: "auth/invalid-cert-hash",
  INVALID_CODE: "auth/invalid-verification-code",
  INVALID_CONTINUE_URI: "auth/invalid-continue-uri",
  INVALID_CORDOVA_CONFIGURATION: "auth/invalid-cordova-configuration",
  INVALID_CUSTOM_TOKEN: "auth/invalid-custom-token",
  INVALID_DYNAMIC_LINK_DOMAIN: "auth/invalid-dynamic-link-domain",
  INVALID_EMAIL: "auth/invalid-email",
  INVALID_EMULATOR_SCHEME: "auth/invalid-emulator-scheme",
  INVALID_IDP_RESPONSE: "auth/invalid-credential",
  INVALID_LOGIN_CREDENTIALS: "auth/invalid-credential",
  INVALID_MESSAGE_PAYLOAD: "auth/invalid-message-payload",
  INVALID_MFA_SESSION: "auth/invalid-multi-factor-session",
  INVALID_OAUTH_CLIENT_ID: "auth/invalid-oauth-client-id",
  INVALID_OAUTH_PROVIDER: "auth/invalid-oauth-provider",
  INVALID_OOB_CODE: "auth/invalid-action-code",
  INVALID_ORIGIN: "auth/unauthorized-domain",
  INVALID_PASSWORD: "auth/wrong-password",
  INVALID_PERSISTENCE: "auth/invalid-persistence-type",
  INVALID_PHONE_NUMBER: "auth/invalid-phone-number",
  INVALID_PROVIDER_ID: "auth/invalid-provider-id",
  INVALID_RECIPIENT_EMAIL: "auth/invalid-recipient-email",
  INVALID_SENDER: "auth/invalid-sender",
  INVALID_SESSION_INFO: "auth/invalid-verification-id",
  INVALID_TENANT_ID: "auth/invalid-tenant-id",
  MFA_INFO_NOT_FOUND: "auth/multi-factor-info-not-found",
  MFA_REQUIRED: "auth/multi-factor-auth-required",
  MISSING_ANDROID_PACKAGE_NAME: "auth/missing-android-pkg-name",
  MISSING_APP_CREDENTIAL: "auth/missing-app-credential",
  MISSING_AUTH_DOMAIN: "auth/auth-domain-config-required",
  MISSING_CODE: "auth/missing-verification-code",
  MISSING_CONTINUE_URI: "auth/missing-continue-uri",
  MISSING_IFRAME_START: "auth/missing-iframe-start",
  MISSING_IOS_BUNDLE_ID: "auth/missing-ios-bundle-id",
  MISSING_OR_INVALID_NONCE: "auth/missing-or-invalid-nonce",
  MISSING_MFA_INFO: "auth/missing-multi-factor-info",
  MISSING_MFA_SESSION: "auth/missing-multi-factor-session",
  MISSING_PHONE_NUMBER: "auth/missing-phone-number",
  MISSING_SESSION_INFO: "auth/missing-verification-id",
  MODULE_DESTROYED: "auth/app-deleted",
  NEED_CONFIRMATION: "auth/account-exists-with-different-credential",
  NETWORK_REQUEST_FAILED: "auth/network-request-failed",
  NULL_USER: "auth/null-user",
  NO_AUTH_EVENT: "auth/no-auth-event",
  NO_SUCH_PROVIDER: "auth/no-such-provider",
  OPERATION_NOT_ALLOWED: "auth/operation-not-allowed",
  OPERATION_NOT_SUPPORTED: "auth/operation-not-supported-in-this-environment",
  POPUP_BLOCKED: "auth/popup-blocked",
  POPUP_CLOSED_BY_USER: "auth/popup-closed-by-user",
  PROVIDER_ALREADY_LINKED: "auth/provider-already-linked",
  QUOTA_EXCEEDED: "auth/quota-exceeded",
  REDIRECT_CANCELLED_BY_USER: "auth/redirect-cancelled-by-user",
  REDIRECT_OPERATION_PENDING: "auth/redirect-operation-pending",
  REJECTED_CREDENTIAL: "auth/rejected-credential",
  SECOND_FACTOR_ALREADY_ENROLLED: "auth/second-factor-already-in-use",
  SECOND_FACTOR_LIMIT_EXCEEDED: "auth/maximum-second-factor-count-exceeded",
  TENANT_ID_MISMATCH: "auth/tenant-id-mismatch",
  TIMEOUT: "auth/timeout",
  TOKEN_EXPIRED: "auth/user-token-expired",
  TOO_MANY_ATTEMPTS_TRY_LATER: "auth/too-many-requests",
  UNAUTHORIZED_DOMAIN: "auth/unauthorized-continue-uri",
  UNSUPPORTED_FIRST_FACTOR: "auth/unsupported-first-factor",
  UNSUPPORTED_PERSISTENCE: "auth/unsupported-persistence-type",
  UNSUPPORTED_TENANT_OPERATION: "auth/unsupported-tenant-operation",
  UNVERIFIED_EMAIL: "auth/unverified-email",
  USER_CANCELLED: "auth/user-cancelled",
  USER_DELETED: "auth/user-not-found",
  USER_DISABLED: "auth/user-disabled",
  USER_MISMATCH: "auth/user-mismatch",
  USER_SIGNED_OUT: "auth/user-signed-out",
  WEAK_PASSWORD: "auth/weak-password",
  WEB_STORAGE_UNSUPPORTED: "auth/web-storage-unsupported",
  ALREADY_INITIALIZED: "auth/already-initialized",
  RECAPTCHA_NOT_ENABLED: "auth/recaptcha-not-enabled",
  MISSING_RECAPTCHA_TOKEN: "auth/missing-recaptcha-token",
  INVALID_RECAPTCHA_TOKEN: "auth/invalid-recaptcha-token",
  INVALID_RECAPTCHA_ACTION: "auth/invalid-recaptcha-action",
  MISSING_CLIENT_TYPE: "auth/missing-client-type",
  MISSING_RECAPTCHA_VERSION: "auth/missing-recaptcha-version",
  INVALID_RECAPTCHA_VERSION: "auth/invalid-recaptcha-version",
  INVALID_REQ_TYPE: "auth/invalid-req-type"
};
var logClient = new Logger("@firebase/auth");
function _logWarn(msg) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (logClient.logLevel <= LogLevel.WARN) {
    logClient.warn.apply(logClient, __spreadArray(["Auth (".concat(SDK_VERSION, "): ").concat(msg)], args, false));
  }
}
function _logError(msg) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (logClient.logLevel <= LogLevel.ERROR) {
    logClient.error.apply(logClient, __spreadArray(["Auth (".concat(SDK_VERSION, "): ").concat(msg)], args, false));
  }
}
function _fail(authOrCode) {
  var rest = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    rest[_i - 1] = arguments[_i];
  }
  throw createErrorInternal.apply(void 0, __spreadArray([authOrCode], rest, false));
}
function _createError(authOrCode) {
  var rest = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    rest[_i - 1] = arguments[_i];
  }
  return createErrorInternal.apply(void 0, __spreadArray([authOrCode], rest, false));
}
function _errorWithCustomMessage(auth, code, message) {
  var _a2;
  var errorMap = __assign(__assign({}, prodErrorMap()), (_a2 = {}, _a2[code] = message, _a2));
  var factory = new ErrorFactory("auth", "Firebase", errorMap);
  return factory.create(code, {
    appName: auth.name
  });
}
function _assertInstanceOf(auth, object, instance) {
  var constructorInstance = instance;
  if (!(object instanceof constructorInstance)) {
    if (constructorInstance.name !== object.constructor.name) {
      _fail(
        auth,
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      );
    }
    throw _errorWithCustomMessage(auth, "argument-error", "Type of ".concat(object.constructor.name, " does not match expected instance.") + "Did you pass a reference from a different Auth SDK?");
  }
}
function createErrorInternal(authOrCode) {
  var _a2;
  var rest = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    rest[_i - 1] = arguments[_i];
  }
  if (typeof authOrCode !== "string") {
    var code = rest[0];
    var fullParams = __spreadArray([], rest.slice(1), true);
    if (fullParams[0]) {
      fullParams[0].appName = authOrCode.name;
    }
    return (_a2 = authOrCode._errorFactory).create.apply(_a2, __spreadArray([code], fullParams, false));
  }
  return _DEFAULT_AUTH_ERROR_FACTORY.create.apply(_DEFAULT_AUTH_ERROR_FACTORY, __spreadArray([authOrCode], rest, false));
}
function _assert(assertion, authOrCode) {
  var rest = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    rest[_i - 2] = arguments[_i];
  }
  if (!assertion) {
    throw createErrorInternal.apply(void 0, __spreadArray([authOrCode], rest, false));
  }
}
function debugFail(failure) {
  var message = "INTERNAL ASSERTION FAILED: " + failure;
  _logError(message);
  throw new Error(message);
}
function debugAssert(assertion, message) {
  if (!assertion) {
    debugFail(message);
  }
}
function _getCurrentUrl() {
  var _a2;
  return typeof self !== "undefined" && ((_a2 = self.location) === null || _a2 === void 0 ? void 0 : _a2.href) || "";
}
function _isHttpOrHttps() {
  return _getCurrentScheme() === "http:" || _getCurrentScheme() === "https:";
}
function _getCurrentScheme() {
  var _a2;
  return typeof self !== "undefined" && ((_a2 = self.location) === null || _a2 === void 0 ? void 0 : _a2.protocol) || null;
}
function _isOnline() {
  if (typeof navigator !== "undefined" && navigator && "onLine" in navigator && typeof navigator.onLine === "boolean" && // Apply only for traditional web apps and Chrome extensions.
  // This is especially true for Cordova apps which have unreliable
  // navigator.onLine behavior unless cordova-plugin-network-information is
  // installed which overwrites the native navigator.onLine value and
  // defines navigator.connection.
  (_isHttpOrHttps() || isBrowserExtension() || "connection" in navigator)) {
    return navigator.onLine;
  }
  return true;
}
function _getUserLanguage() {
  if (typeof navigator === "undefined") {
    return null;
  }
  var navigatorLanguage = navigator;
  return (
    // Most reliable, but only supported in Chrome/Firefox.
    navigatorLanguage.languages && navigatorLanguage.languages[0] || // Supported in most browsers, but returns the language of the browser
    // UI, not the language set in browser settings.
    navigatorLanguage.language || // Couldn't determine language.
    null
  );
}
var Delay = (
  /** @class */
  function() {
    function Delay2(shortDelay, longDelay) {
      this.shortDelay = shortDelay;
      this.longDelay = longDelay;
      debugAssert(longDelay > shortDelay, "Short delay should be less than long delay!");
      this.isMobile = isMobileCordova() || isReactNative();
    }
    Delay2.prototype.get = function() {
      if (!_isOnline()) {
        return Math.min(5e3, this.shortDelay);
      }
      return this.isMobile ? this.longDelay : this.shortDelay;
    };
    return Delay2;
  }()
);
function _emulatorUrl(config, path) {
  debugAssert(config.emulator, "Emulator should always be set here");
  var url = config.emulator.url;
  if (!path) {
    return url;
  }
  return "".concat(url).concat(path.startsWith("/") ? path.slice(1) : path);
}
var FetchProvider = (
  /** @class */
  function() {
    function FetchProvider2() {
    }
    FetchProvider2.initialize = function(fetchImpl, headersImpl, responseImpl) {
      this.fetchImpl = fetchImpl;
      if (headersImpl) {
        this.headersImpl = headersImpl;
      }
      if (responseImpl) {
        this.responseImpl = responseImpl;
      }
    };
    FetchProvider2.fetch = function() {
      if (this.fetchImpl) {
        return this.fetchImpl;
      }
      if (typeof self !== "undefined" && "fetch" in self) {
        return self.fetch;
      }
      if (typeof globalThis !== "undefined" && globalThis.fetch) {
        return globalThis.fetch;
      }
      if (typeof fetch !== "undefined") {
        return fetch;
      }
      debugFail("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
    };
    FetchProvider2.headers = function() {
      if (this.headersImpl) {
        return this.headersImpl;
      }
      if (typeof self !== "undefined" && "Headers" in self) {
        return self.Headers;
      }
      if (typeof globalThis !== "undefined" && globalThis.Headers) {
        return globalThis.Headers;
      }
      if (typeof Headers !== "undefined") {
        return Headers;
      }
      debugFail("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
    };
    FetchProvider2.response = function() {
      if (this.responseImpl) {
        return this.responseImpl;
      }
      if (typeof self !== "undefined" && "Response" in self) {
        return self.Response;
      }
      if (typeof globalThis !== "undefined" && globalThis.Response) {
        return globalThis.Response;
      }
      if (typeof Response !== "undefined") {
        return Response;
      }
      debugFail("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
    };
    return FetchProvider2;
  }()
);
var _a$1;
var SERVER_ERROR_MAP = (_a$1 = {}, // Custom token errors.
_a$1[
  "CREDENTIAL_MISMATCH"
  /* ServerError.CREDENTIAL_MISMATCH */
] = "custom-token-mismatch", // This can only happen if the SDK sends a bad request.
_a$1[
  "MISSING_CUSTOM_TOKEN"
  /* ServerError.MISSING_CUSTOM_TOKEN */
] = "internal-error", // Create Auth URI errors.
_a$1[
  "INVALID_IDENTIFIER"
  /* ServerError.INVALID_IDENTIFIER */
] = "invalid-email", // This can only happen if the SDK sends a bad request.
_a$1[
  "MISSING_CONTINUE_URI"
  /* ServerError.MISSING_CONTINUE_URI */
] = "internal-error", // Sign in with email and password errors (some apply to sign up too).
_a$1[
  "INVALID_PASSWORD"
  /* ServerError.INVALID_PASSWORD */
] = "wrong-password", // This can only happen if the SDK sends a bad request.
_a$1[
  "MISSING_PASSWORD"
  /* ServerError.MISSING_PASSWORD */
] = "missing-password", // Thrown if Email Enumeration Protection is enabled in the project and the email or password is
// invalid.
_a$1[
  "INVALID_LOGIN_CREDENTIALS"
  /* ServerError.INVALID_LOGIN_CREDENTIALS */
] = "invalid-credential", // Sign up with email and password errors.
_a$1[
  "EMAIL_EXISTS"
  /* ServerError.EMAIL_EXISTS */
] = "email-already-in-use", _a$1[
  "PASSWORD_LOGIN_DISABLED"
  /* ServerError.PASSWORD_LOGIN_DISABLED */
] = "operation-not-allowed", // Verify assertion for sign in with credential errors:
_a$1[
  "INVALID_IDP_RESPONSE"
  /* ServerError.INVALID_IDP_RESPONSE */
] = "invalid-credential", _a$1[
  "INVALID_PENDING_TOKEN"
  /* ServerError.INVALID_PENDING_TOKEN */
] = "invalid-credential", _a$1[
  "FEDERATED_USER_ID_ALREADY_LINKED"
  /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */
] = "credential-already-in-use", // This can only happen if the SDK sends a bad request.
_a$1[
  "MISSING_REQ_TYPE"
  /* ServerError.MISSING_REQ_TYPE */
] = "internal-error", // Send Password reset email errors:
_a$1[
  "EMAIL_NOT_FOUND"
  /* ServerError.EMAIL_NOT_FOUND */
] = "user-not-found", _a$1[
  "RESET_PASSWORD_EXCEED_LIMIT"
  /* ServerError.RESET_PASSWORD_EXCEED_LIMIT */
] = "too-many-requests", _a$1[
  "EXPIRED_OOB_CODE"
  /* ServerError.EXPIRED_OOB_CODE */
] = "expired-action-code", _a$1[
  "INVALID_OOB_CODE"
  /* ServerError.INVALID_OOB_CODE */
] = "invalid-action-code", // This can only happen if the SDK sends a bad request.
_a$1[
  "MISSING_OOB_CODE"
  /* ServerError.MISSING_OOB_CODE */
] = "internal-error", // Operations that require ID token in request:
_a$1[
  "CREDENTIAL_TOO_OLD_LOGIN_AGAIN"
  /* ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */
] = "requires-recent-login", _a$1[
  "INVALID_ID_TOKEN"
  /* ServerError.INVALID_ID_TOKEN */
] = "invalid-user-token", _a$1[
  "TOKEN_EXPIRED"
  /* ServerError.TOKEN_EXPIRED */
] = "user-token-expired", _a$1[
  "USER_NOT_FOUND"
  /* ServerError.USER_NOT_FOUND */
] = "user-token-expired", // Other errors.
_a$1[
  "TOO_MANY_ATTEMPTS_TRY_LATER"
  /* ServerError.TOO_MANY_ATTEMPTS_TRY_LATER */
] = "too-many-requests", _a$1[
  "PASSWORD_DOES_NOT_MEET_REQUIREMENTS"
  /* ServerError.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */
] = "password-does-not-meet-requirements", // Phone Auth related errors.
_a$1[
  "INVALID_CODE"
  /* ServerError.INVALID_CODE */
] = "invalid-verification-code", _a$1[
  "INVALID_SESSION_INFO"
  /* ServerError.INVALID_SESSION_INFO */
] = "invalid-verification-id", _a$1[
  "INVALID_TEMPORARY_PROOF"
  /* ServerError.INVALID_TEMPORARY_PROOF */
] = "invalid-credential", _a$1[
  "MISSING_SESSION_INFO"
  /* ServerError.MISSING_SESSION_INFO */
] = "missing-verification-id", _a$1[
  "SESSION_EXPIRED"
  /* ServerError.SESSION_EXPIRED */
] = "code-expired", // Other action code errors when additional settings passed.
// MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.
// This is OK as this error will be caught by client side validation.
_a$1[
  "MISSING_ANDROID_PACKAGE_NAME"
  /* ServerError.MISSING_ANDROID_PACKAGE_NAME */
] = "missing-android-pkg-name", _a$1[
  "UNAUTHORIZED_DOMAIN"
  /* ServerError.UNAUTHORIZED_DOMAIN */
] = "unauthorized-continue-uri", // getProjectConfig errors when clientId is passed.
_a$1[
  "INVALID_OAUTH_CLIENT_ID"
  /* ServerError.INVALID_OAUTH_CLIENT_ID */
] = "invalid-oauth-client-id", // User actions (sign-up or deletion) disabled errors.
_a$1[
  "ADMIN_ONLY_OPERATION"
  /* ServerError.ADMIN_ONLY_OPERATION */
] = "admin-restricted-operation", // Multi factor related errors.
_a$1[
  "INVALID_MFA_PENDING_CREDENTIAL"
  /* ServerError.INVALID_MFA_PENDING_CREDENTIAL */
] = "invalid-multi-factor-session", _a$1[
  "MFA_ENROLLMENT_NOT_FOUND"
  /* ServerError.MFA_ENROLLMENT_NOT_FOUND */
] = "multi-factor-info-not-found", _a$1[
  "MISSING_MFA_ENROLLMENT_ID"
  /* ServerError.MISSING_MFA_ENROLLMENT_ID */
] = "missing-multi-factor-info", _a$1[
  "MISSING_MFA_PENDING_CREDENTIAL"
  /* ServerError.MISSING_MFA_PENDING_CREDENTIAL */
] = "missing-multi-factor-session", _a$1[
  "SECOND_FACTOR_EXISTS"
  /* ServerError.SECOND_FACTOR_EXISTS */
] = "second-factor-already-in-use", _a$1[
  "SECOND_FACTOR_LIMIT_EXCEEDED"
  /* ServerError.SECOND_FACTOR_LIMIT_EXCEEDED */
] = "maximum-second-factor-count-exceeded", // Blocking functions related errors.
_a$1[
  "BLOCKING_FUNCTION_ERROR_RESPONSE"
  /* ServerError.BLOCKING_FUNCTION_ERROR_RESPONSE */
] = "internal-error", // Recaptcha related errors.
_a$1[
  "RECAPTCHA_NOT_ENABLED"
  /* ServerError.RECAPTCHA_NOT_ENABLED */
] = "recaptcha-not-enabled", _a$1[
  "MISSING_RECAPTCHA_TOKEN"
  /* ServerError.MISSING_RECAPTCHA_TOKEN */
] = "missing-recaptcha-token", _a$1[
  "INVALID_RECAPTCHA_TOKEN"
  /* ServerError.INVALID_RECAPTCHA_TOKEN */
] = "invalid-recaptcha-token", _a$1[
  "INVALID_RECAPTCHA_ACTION"
  /* ServerError.INVALID_RECAPTCHA_ACTION */
] = "invalid-recaptcha-action", _a$1[
  "MISSING_CLIENT_TYPE"
  /* ServerError.MISSING_CLIENT_TYPE */
] = "missing-client-type", _a$1[
  "MISSING_RECAPTCHA_VERSION"
  /* ServerError.MISSING_RECAPTCHA_VERSION */
] = "missing-recaptcha-version", _a$1[
  "INVALID_RECAPTCHA_VERSION"
  /* ServerError.INVALID_RECAPTCHA_VERSION */
] = "invalid-recaptcha-version", _a$1[
  "INVALID_REQ_TYPE"
  /* ServerError.INVALID_REQ_TYPE */
] = "invalid-req-type", _a$1);
var DEFAULT_API_TIMEOUT_MS = new Delay(3e4, 6e4);
function _addTidIfNecessary(auth, request) {
  if (auth.tenantId && !request.tenantId) {
    return __assign(__assign({}, request), { tenantId: auth.tenantId });
  }
  return request;
}
function _performApiRequest(auth, method, path, request, customErrorMap) {
  if (customErrorMap === void 0) {
    customErrorMap = {};
  }
  return __awaiter(this, void 0, void 0, function() {
    var _this = this;
    return __generator(this, function(_a2) {
      return [2, _performFetchWithErrorHandling(auth, customErrorMap, function() {
        return __awaiter(_this, void 0, void 0, function() {
          var body, params, query, headers;
          return __generator(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                body = {};
                params = {};
                if (request) {
                  if (method === "GET") {
                    params = request;
                  } else {
                    body = {
                      body: JSON.stringify(request)
                    };
                  }
                }
                query = querystring(__assign({ key: auth.config.apiKey }, params)).slice(1);
                return [4, auth._getAdditionalHeaders()];
              case 1:
                headers = _a3.sent();
                headers[
                  "Content-Type"
                  /* HttpHeader.CONTENT_TYPE */
                ] = "application/json";
                if (auth.languageCode) {
                  headers[
                    "X-Firebase-Locale"
                    /* HttpHeader.X_FIREBASE_LOCALE */
                  ] = auth.languageCode;
                }
                return [2, FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), __assign({ method, headers, referrerPolicy: "no-referrer" }, body))];
            }
          });
        });
      })];
    });
  });
}
function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {
  return __awaiter(this, void 0, void 0, function() {
    var errorMap, networkTimeout, response, json, errorMessage, _a2, serverErrorCode, serverErrorMessage, authError, e_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          auth._canInitEmulator = false;
          errorMap = __assign(__assign({}, SERVER_ERROR_MAP), customErrorMap);
          _b.label = 1;
        case 1:
          _b.trys.push([1, 4, , 5]);
          networkTimeout = new NetworkTimeout(auth);
          return [4, Promise.race([
            fetchFn(),
            networkTimeout.promise
          ])];
        case 2:
          response = _b.sent();
          networkTimeout.clearNetworkTimeout();
          return [4, response.json()];
        case 3:
          json = _b.sent();
          if ("needConfirmation" in json) {
            throw _makeTaggedError(auth, "account-exists-with-different-credential", json);
          }
          if (response.ok && !("errorMessage" in json)) {
            return [2, json];
          } else {
            errorMessage = response.ok ? json.errorMessage : json.error.message;
            _a2 = errorMessage.split(" : "), serverErrorCode = _a2[0], serverErrorMessage = _a2[1];
            if (serverErrorCode === "FEDERATED_USER_ID_ALREADY_LINKED") {
              throw _makeTaggedError(auth, "credential-already-in-use", json);
            } else if (serverErrorCode === "EMAIL_EXISTS") {
              throw _makeTaggedError(auth, "email-already-in-use", json);
            } else if (serverErrorCode === "USER_DISABLED") {
              throw _makeTaggedError(auth, "user-disabled", json);
            }
            authError = errorMap[serverErrorCode] || serverErrorCode.toLowerCase().replace(/[_\s]+/g, "-");
            if (serverErrorMessage) {
              throw _errorWithCustomMessage(auth, authError, serverErrorMessage);
            } else {
              _fail(auth, authError);
            }
          }
          return [3, 5];
        case 4:
          e_1 = _b.sent();
          if (e_1 instanceof FirebaseError) {
            throw e_1;
          }
          _fail(auth, "network-request-failed", { "message": String(e_1) });
          return [3, 5];
        case 5:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function _performSignInRequest(auth, method, path, request, customErrorMap) {
  if (customErrorMap === void 0) {
    customErrorMap = {};
  }
  return __awaiter(this, void 0, void 0, function() {
    var serverResponse;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, _performApiRequest(auth, method, path, request, customErrorMap)];
        case 1:
          serverResponse = _a2.sent();
          if ("mfaPendingCredential" in serverResponse) {
            _fail(auth, "multi-factor-auth-required", {
              _serverResponse: serverResponse
            });
          }
          return [2, serverResponse];
      }
    });
  });
}
function _getFinalTarget(auth, host, path, query) {
  var base = "".concat(host).concat(path, "?").concat(query);
  if (!auth.config.emulator) {
    return "".concat(auth.config.apiScheme, "://").concat(base);
  }
  return _emulatorUrl(auth.config, base);
}
function _parseEnforcementState(enforcementStateStr) {
  switch (enforcementStateStr) {
    case "ENFORCE":
      return "ENFORCE";
    case "AUDIT":
      return "AUDIT";
    case "OFF":
      return "OFF";
    default:
      return "ENFORCEMENT_STATE_UNSPECIFIED";
  }
}
var NetworkTimeout = (
  /** @class */
  function() {
    function NetworkTimeout2(auth) {
      var _this = this;
      this.auth = auth;
      this.timer = null;
      this.promise = new Promise(function(_, reject) {
        _this.timer = setTimeout(function() {
          return reject(_createError(
            _this.auth,
            "network-request-failed"
            /* AuthErrorCode.NETWORK_REQUEST_FAILED */
          ));
        }, DEFAULT_API_TIMEOUT_MS.get());
      });
    }
    NetworkTimeout2.prototype.clearNetworkTimeout = function() {
      clearTimeout(this.timer);
    };
    return NetworkTimeout2;
  }()
);
function _makeTaggedError(auth, code, response) {
  var errorParams = {
    appName: auth.name
  };
  if (response.email) {
    errorParams.email = response.email;
  }
  if (response.phoneNumber) {
    errorParams.phoneNumber = response.phoneNumber;
  }
  var error = _createError(auth, code, errorParams);
  error.customData._tokenResponse = response;
  return error;
}
function isEnterprise(grecaptcha) {
  return grecaptcha !== void 0 && grecaptcha.enterprise !== void 0;
}
var RecaptchaConfig = (
  /** @class */
  function() {
    function RecaptchaConfig2(response) {
      this.siteKey = "";
      this.recaptchaEnforcementState = [];
      if (response.recaptchaKey === void 0) {
        throw new Error("recaptchaKey undefined");
      }
      this.siteKey = response.recaptchaKey.split("/")[3];
      this.recaptchaEnforcementState = response.recaptchaEnforcementState;
    }
    RecaptchaConfig2.prototype.getProviderEnforcementState = function(providerStr) {
      if (!this.recaptchaEnforcementState || this.recaptchaEnforcementState.length === 0) {
        return null;
      }
      for (var _i = 0, _a2 = this.recaptchaEnforcementState; _i < _a2.length; _i++) {
        var recaptchaEnforcementState = _a2[_i];
        if (recaptchaEnforcementState.provider && recaptchaEnforcementState.provider === providerStr) {
          return _parseEnforcementState(recaptchaEnforcementState.enforcementState);
        }
      }
      return null;
    };
    RecaptchaConfig2.prototype.isProviderEnabled = function(providerStr) {
      return this.getProviderEnforcementState(providerStr) === "ENFORCE" || this.getProviderEnforcementState(providerStr) === "AUDIT";
    };
    return RecaptchaConfig2;
  }()
);
function getRecaptchaConfig(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "GET", "/v2/recaptchaConfig", _addTidIfNecessary(auth, request))];
    });
  });
}
function deleteAccount(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "POST", "/v1/accounts:delete", request)];
    });
  });
}
function deleteLinkedAccounts(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "POST", "/v1/accounts:update", request)];
    });
  });
}
function getAccountInfo(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "POST", "/v1/accounts:lookup", request)];
    });
  });
}
function utcTimestampToDateString(utcTimestamp) {
  if (!utcTimestamp) {
    return void 0;
  }
  try {
    var date = new Date(Number(utcTimestamp));
    if (!isNaN(date.getTime())) {
      return date.toUTCString();
    }
  } catch (e) {
  }
  return void 0;
}
function getIdToken(user, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  return getModularInstance(user).getIdToken(forceRefresh);
}
function getIdTokenResult(user, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var userInternal, token, claims, firebase, signInProvider;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          userInternal = getModularInstance(user);
          return [4, userInternal.getIdToken(forceRefresh)];
        case 1:
          token = _a2.sent();
          claims = _parseToken(token);
          _assert(
            claims && claims.exp && claims.auth_time && claims.iat,
            userInternal.auth,
            "internal-error"
            /* AuthErrorCode.INTERNAL_ERROR */
          );
          firebase = typeof claims.firebase === "object" ? claims.firebase : void 0;
          signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase["sign_in_provider"];
          return [2, {
            claims,
            token,
            authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),
            issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),
            expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),
            signInProvider: signInProvider || null,
            signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase["sign_in_second_factor"]) || null
          }];
      }
    });
  });
}
function secondsStringToMilliseconds(seconds) {
  return Number(seconds) * 1e3;
}
function _parseToken(token) {
  var _a2 = token.split("."), algorithm = _a2[0], payload = _a2[1], signature = _a2[2];
  if (algorithm === void 0 || payload === void 0 || signature === void 0) {
    _logError("JWT malformed, contained fewer than 3 sections");
    return null;
  }
  try {
    var decoded = base64Decode(payload);
    if (!decoded) {
      _logError("Failed to decode base64 JWT payload");
      return null;
    }
    return JSON.parse(decoded);
  } catch (e) {
    _logError("Caught error parsing JWT payload as JSON", e === null || e === void 0 ? void 0 : e.toString());
    return null;
  }
}
function _tokenExpiresIn(token) {
  var parsedToken = _parseToken(token);
  _assert(
    parsedToken,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  _assert(
    typeof parsedToken.exp !== "undefined",
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  _assert(
    typeof parsedToken.iat !== "undefined",
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  return Number(parsedToken.exp) - Number(parsedToken.iat);
}
function _logoutIfInvalidated(user, promise, bypassAuthState) {
  if (bypassAuthState === void 0) {
    bypassAuthState = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var e_1;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          if (bypassAuthState) {
            return [2, promise];
          }
          _a2.label = 1;
        case 1:
          _a2.trys.push([1, 3, , 6]);
          return [4, promise];
        case 2:
          return [2, _a2.sent()];
        case 3:
          e_1 = _a2.sent();
          if (!(e_1 instanceof FirebaseError && isUserInvalidated(e_1)))
            return [3, 5];
          if (!(user.auth.currentUser === user))
            return [3, 5];
          return [4, user.auth.signOut()];
        case 4:
          _a2.sent();
          _a2.label = 5;
        case 5:
          throw e_1;
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function isUserInvalidated(_a2) {
  var code = _a2.code;
  return code === "auth/".concat(
    "user-disabled"
    /* AuthErrorCode.USER_DISABLED */
  ) || code === "auth/".concat(
    "user-token-expired"
    /* AuthErrorCode.TOKEN_EXPIRED */
  );
}
var ProactiveRefresh = (
  /** @class */
  function() {
    function ProactiveRefresh2(user) {
      this.user = user;
      this.isRunning = false;
      this.timerId = null;
      this.errorBackoff = 3e4;
    }
    ProactiveRefresh2.prototype._start = function() {
      if (this.isRunning) {
        return;
      }
      this.isRunning = true;
      this.schedule();
    };
    ProactiveRefresh2.prototype._stop = function() {
      if (!this.isRunning) {
        return;
      }
      this.isRunning = false;
      if (this.timerId !== null) {
        clearTimeout(this.timerId);
      }
    };
    ProactiveRefresh2.prototype.getInterval = function(wasError) {
      var _a2;
      if (wasError) {
        var interval = this.errorBackoff;
        this.errorBackoff = Math.min(
          this.errorBackoff * 2,
          96e4
          /* Duration.RETRY_BACKOFF_MAX */
        );
        return interval;
      } else {
        this.errorBackoff = 3e4;
        var expTime = (_a2 = this.user.stsTokenManager.expirationTime) !== null && _a2 !== void 0 ? _a2 : 0;
        var interval = expTime - Date.now() - 3e5;
        return Math.max(0, interval);
      }
    };
    ProactiveRefresh2.prototype.schedule = function(wasError) {
      var _this = this;
      if (wasError === void 0) {
        wasError = false;
      }
      if (!this.isRunning) {
        return;
      }
      var interval = this.getInterval(wasError);
      this.timerId = setTimeout(function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.iteration()];
              case 1:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, interval);
    };
    ProactiveRefresh2.prototype.iteration = function() {
      return __awaiter(this, void 0, void 0, function() {
        var e_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, 2, , 3]);
              return [4, this.user.getIdToken(true)];
            case 1:
              _a2.sent();
              return [3, 3];
            case 2:
              e_1 = _a2.sent();
              if ((e_1 === null || e_1 === void 0 ? void 0 : e_1.code) === "auth/".concat(
                "network-request-failed"
                /* AuthErrorCode.NETWORK_REQUEST_FAILED */
              )) {
                this.schedule(
                  /* wasError */
                  true
                );
              }
              return [
                2
                /*return*/
              ];
            case 3:
              this.schedule();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    return ProactiveRefresh2;
  }()
);
var UserMetadata = (
  /** @class */
  function() {
    function UserMetadata2(createdAt, lastLoginAt) {
      this.createdAt = createdAt;
      this.lastLoginAt = lastLoginAt;
      this._initializeTime();
    }
    UserMetadata2.prototype._initializeTime = function() {
      this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);
      this.creationTime = utcTimestampToDateString(this.createdAt);
    };
    UserMetadata2.prototype._copy = function(metadata) {
      this.createdAt = metadata.createdAt;
      this.lastLoginAt = metadata.lastLoginAt;
      this._initializeTime();
    };
    UserMetadata2.prototype.toJSON = function() {
      return {
        createdAt: this.createdAt,
        lastLoginAt: this.lastLoginAt
      };
    };
    return UserMetadata2;
  }()
);
function _reloadWithoutSaving(user) {
  var _a2;
  return __awaiter(this, void 0, void 0, function() {
    var auth, idToken, response, coreAccount, newProviderData, providerData, oldIsAnonymous, newIsAnonymous, isAnonymous, updates;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          auth = user.auth;
          return [4, user.getIdToken()];
        case 1:
          idToken = _b.sent();
          return [4, _logoutIfInvalidated(user, getAccountInfo(auth, { idToken }))];
        case 2:
          response = _b.sent();
          _assert(
            response === null || response === void 0 ? void 0 : response.users.length,
            auth,
            "internal-error"
            /* AuthErrorCode.INTERNAL_ERROR */
          );
          coreAccount = response.users[0];
          user._notifyReloadListener(coreAccount);
          newProviderData = ((_a2 = coreAccount.providerUserInfo) === null || _a2 === void 0 ? void 0 : _a2.length) ? extractProviderData(coreAccount.providerUserInfo) : [];
          providerData = mergeProviderData(user.providerData, newProviderData);
          oldIsAnonymous = user.isAnonymous;
          newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);
          isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;
          updates = {
            uid: coreAccount.localId,
            displayName: coreAccount.displayName || null,
            photoURL: coreAccount.photoUrl || null,
            email: coreAccount.email || null,
            emailVerified: coreAccount.emailVerified || false,
            phoneNumber: coreAccount.phoneNumber || null,
            tenantId: coreAccount.tenantId || null,
            providerData,
            metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),
            isAnonymous
          };
          Object.assign(user, updates);
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function reload(user) {
  return __awaiter(this, void 0, void 0, function() {
    var userInternal;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          userInternal = getModularInstance(user);
          return [4, _reloadWithoutSaving(userInternal)];
        case 1:
          _a2.sent();
          return [4, userInternal.auth._persistUserIfCurrent(userInternal)];
        case 2:
          _a2.sent();
          userInternal.auth._notifyListenersIfCurrent(userInternal);
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function mergeProviderData(original, newData) {
  var deduped = original.filter(function(o) {
    return !newData.some(function(n) {
      return n.providerId === o.providerId;
    });
  });
  return __spreadArray(__spreadArray([], deduped, true), newData, true);
}
function extractProviderData(providers) {
  return providers.map(function(_a2) {
    var providerId = _a2.providerId, provider = __rest(_a2, ["providerId"]);
    return {
      providerId,
      uid: provider.rawId || "",
      displayName: provider.displayName || null,
      email: provider.email || null,
      phoneNumber: provider.phoneNumber || null,
      photoURL: provider.photoUrl || null
    };
  });
}
function requestStsToken(auth, refreshToken) {
  return __awaiter(this, void 0, void 0, function() {
    var response;
    var _this = this;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, _performFetchWithErrorHandling(auth, {}, function() {
            return __awaiter(_this, void 0, void 0, function() {
              var body, _a3, tokenApiHost, apiKey, url, headers;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    body = querystring({
                      "grant_type": "refresh_token",
                      "refresh_token": refreshToken
                    }).slice(1);
                    _a3 = auth.config, tokenApiHost = _a3.tokenApiHost, apiKey = _a3.apiKey;
                    url = _getFinalTarget(auth, tokenApiHost, "/v1/token", "key=".concat(apiKey));
                    return [4, auth._getAdditionalHeaders()];
                  case 1:
                    headers = _b.sent();
                    headers[
                      "Content-Type"
                      /* HttpHeader.CONTENT_TYPE */
                    ] = "application/x-www-form-urlencoded";
                    return [2, FetchProvider.fetch()(url, {
                      method: "POST",
                      headers,
                      body
                    })];
                }
              });
            });
          })];
        case 1:
          response = _a2.sent();
          return [2, {
            accessToken: response.access_token,
            expiresIn: response.expires_in,
            refreshToken: response.refresh_token
          }];
      }
    });
  });
}
function revokeToken(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "POST", "/v2/accounts:revokeToken", _addTidIfNecessary(auth, request))];
    });
  });
}
var StsTokenManager = (
  /** @class */
  function() {
    function StsTokenManager2() {
      this.refreshToken = null;
      this.accessToken = null;
      this.expirationTime = null;
    }
    Object.defineProperty(StsTokenManager2.prototype, "isExpired", {
      get: function() {
        return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
      },
      enumerable: false,
      configurable: true
    });
    StsTokenManager2.prototype.updateFromServerResponse = function(response) {
      _assert(
        response.idToken,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      _assert(
        typeof response.idToken !== "undefined",
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      _assert(
        typeof response.refreshToken !== "undefined",
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      var expiresIn = "expiresIn" in response && typeof response.expiresIn !== "undefined" ? Number(response.expiresIn) : _tokenExpiresIn(response.idToken);
      this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);
    };
    StsTokenManager2.prototype.getToken = function(auth, forceRefresh) {
      if (forceRefresh === void 0) {
        forceRefresh = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _assert(
                !this.accessToken || this.refreshToken,
                auth,
                "user-token-expired"
                /* AuthErrorCode.TOKEN_EXPIRED */
              );
              if (!forceRefresh && this.accessToken && !this.isExpired) {
                return [2, this.accessToken];
              }
              if (!this.refreshToken)
                return [3, 2];
              return [4, this.refresh(auth, this.refreshToken)];
            case 1:
              _a2.sent();
              return [2, this.accessToken];
            case 2:
              return [2, null];
          }
        });
      });
    };
    StsTokenManager2.prototype.clearRefreshToken = function() {
      this.refreshToken = null;
    };
    StsTokenManager2.prototype.refresh = function(auth, oldToken) {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, accessToken, refreshToken, expiresIn;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, requestStsToken(auth, oldToken)];
            case 1:
              _a2 = _b.sent(), accessToken = _a2.accessToken, refreshToken = _a2.refreshToken, expiresIn = _a2.expiresIn;
              this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    StsTokenManager2.prototype.updateTokensAndExpiration = function(accessToken, refreshToken, expiresInSec) {
      this.refreshToken = refreshToken || null;
      this.accessToken = accessToken || null;
      this.expirationTime = Date.now() + expiresInSec * 1e3;
    };
    StsTokenManager2.fromJSON = function(appName, object) {
      var refreshToken = object.refreshToken, accessToken = object.accessToken, expirationTime = object.expirationTime;
      var manager = new StsTokenManager2();
      if (refreshToken) {
        _assert(typeof refreshToken === "string", "internal-error", {
          appName
        });
        manager.refreshToken = refreshToken;
      }
      if (accessToken) {
        _assert(typeof accessToken === "string", "internal-error", {
          appName
        });
        manager.accessToken = accessToken;
      }
      if (expirationTime) {
        _assert(typeof expirationTime === "number", "internal-error", {
          appName
        });
        manager.expirationTime = expirationTime;
      }
      return manager;
    };
    StsTokenManager2.prototype.toJSON = function() {
      return {
        refreshToken: this.refreshToken,
        accessToken: this.accessToken,
        expirationTime: this.expirationTime
      };
    };
    StsTokenManager2.prototype._assign = function(stsTokenManager) {
      this.accessToken = stsTokenManager.accessToken;
      this.refreshToken = stsTokenManager.refreshToken;
      this.expirationTime = stsTokenManager.expirationTime;
    };
    StsTokenManager2.prototype._clone = function() {
      return Object.assign(new StsTokenManager2(), this.toJSON());
    };
    StsTokenManager2.prototype._performRefresh = function() {
      return debugFail("not implemented");
    };
    return StsTokenManager2;
  }()
);
function assertStringOrUndefined(assertion, appName) {
  _assert(typeof assertion === "string" || typeof assertion === "undefined", "internal-error", { appName });
}
var UserImpl = (
  /** @class */
  function() {
    function UserImpl2(_a2) {
      var uid = _a2.uid, auth = _a2.auth, stsTokenManager = _a2.stsTokenManager, opt = __rest(_a2, ["uid", "auth", "stsTokenManager"]);
      this.providerId = "firebase";
      this.proactiveRefresh = new ProactiveRefresh(this);
      this.reloadUserInfo = null;
      this.reloadListener = null;
      this.uid = uid;
      this.auth = auth;
      this.stsTokenManager = stsTokenManager;
      this.accessToken = stsTokenManager.accessToken;
      this.displayName = opt.displayName || null;
      this.email = opt.email || null;
      this.emailVerified = opt.emailVerified || false;
      this.phoneNumber = opt.phoneNumber || null;
      this.photoURL = opt.photoURL || null;
      this.isAnonymous = opt.isAnonymous || false;
      this.tenantId = opt.tenantId || null;
      this.providerData = opt.providerData ? __spreadArray([], opt.providerData, true) : [];
      this.metadata = new UserMetadata(opt.createdAt || void 0, opt.lastLoginAt || void 0);
    }
    UserImpl2.prototype.getIdToken = function(forceRefresh) {
      return __awaiter(this, void 0, void 0, function() {
        var accessToken;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh))];
            case 1:
              accessToken = _a2.sent();
              _assert(
                accessToken,
                this.auth,
                "internal-error"
                /* AuthErrorCode.INTERNAL_ERROR */
              );
              if (!(this.accessToken !== accessToken))
                return [3, 3];
              this.accessToken = accessToken;
              return [4, this.auth._persistUserIfCurrent(this)];
            case 2:
              _a2.sent();
              this.auth._notifyListenersIfCurrent(this);
              _a2.label = 3;
            case 3:
              return [2, accessToken];
          }
        });
      });
    };
    UserImpl2.prototype.getIdTokenResult = function(forceRefresh) {
      return getIdTokenResult(this, forceRefresh);
    };
    UserImpl2.prototype.reload = function() {
      return reload(this);
    };
    UserImpl2.prototype._assign = function(user) {
      if (this === user) {
        return;
      }
      _assert(
        this.uid === user.uid,
        this.auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      this.displayName = user.displayName;
      this.photoURL = user.photoURL;
      this.email = user.email;
      this.emailVerified = user.emailVerified;
      this.phoneNumber = user.phoneNumber;
      this.isAnonymous = user.isAnonymous;
      this.tenantId = user.tenantId;
      this.providerData = user.providerData.map(function(userInfo) {
        return __assign({}, userInfo);
      });
      this.metadata._copy(user.metadata);
      this.stsTokenManager._assign(user.stsTokenManager);
    };
    UserImpl2.prototype._clone = function(auth) {
      var newUser = new UserImpl2(__assign(__assign({}, this), { auth, stsTokenManager: this.stsTokenManager._clone() }));
      newUser.metadata._copy(this.metadata);
      return newUser;
    };
    UserImpl2.prototype._onReload = function(callback) {
      _assert(
        !this.reloadListener,
        this.auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      this.reloadListener = callback;
      if (this.reloadUserInfo) {
        this._notifyReloadListener(this.reloadUserInfo);
        this.reloadUserInfo = null;
      }
    };
    UserImpl2.prototype._notifyReloadListener = function(userInfo) {
      if (this.reloadListener) {
        this.reloadListener(userInfo);
      } else {
        this.reloadUserInfo = userInfo;
      }
    };
    UserImpl2.prototype._startProactiveRefresh = function() {
      this.proactiveRefresh._start();
    };
    UserImpl2.prototype._stopProactiveRefresh = function() {
      this.proactiveRefresh._stop();
    };
    UserImpl2.prototype._updateTokensIfNecessary = function(response, reload2) {
      if (reload2 === void 0) {
        reload2 = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        var tokensRefreshed;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              tokensRefreshed = false;
              if (response.idToken && response.idToken !== this.stsTokenManager.accessToken) {
                this.stsTokenManager.updateFromServerResponse(response);
                tokensRefreshed = true;
              }
              if (!reload2)
                return [3, 2];
              return [4, _reloadWithoutSaving(this)];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              return [4, this.auth._persistUserIfCurrent(this)];
            case 3:
              _a2.sent();
              if (tokensRefreshed) {
                this.auth._notifyListenersIfCurrent(this);
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    UserImpl2.prototype.delete = function() {
      return __awaiter(this, void 0, void 0, function() {
        var idToken;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.getIdToken()];
            case 1:
              idToken = _a2.sent();
              return [4, _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }))];
            case 2:
              _a2.sent();
              this.stsTokenManager.clearRefreshToken();
              return [2, this.auth.signOut()];
          }
        });
      });
    };
    UserImpl2.prototype.toJSON = function() {
      return __assign(__assign({
        uid: this.uid,
        email: this.email || void 0,
        emailVerified: this.emailVerified,
        displayName: this.displayName || void 0,
        isAnonymous: this.isAnonymous,
        photoURL: this.photoURL || void 0,
        phoneNumber: this.phoneNumber || void 0,
        tenantId: this.tenantId || void 0,
        providerData: this.providerData.map(function(userInfo) {
          return __assign({}, userInfo);
        }),
        stsTokenManager: this.stsTokenManager.toJSON(),
        // Redirect event ID must be maintained in case there is a pending
        // redirect event.
        _redirectEventId: this._redirectEventId
      }, this.metadata.toJSON()), {
        // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):
        apiKey: this.auth.config.apiKey,
        appName: this.auth.name
      });
    };
    Object.defineProperty(UserImpl2.prototype, "refreshToken", {
      get: function() {
        return this.stsTokenManager.refreshToken || "";
      },
      enumerable: false,
      configurable: true
    });
    UserImpl2._fromJSON = function(auth, object) {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      var displayName = (_a2 = object.displayName) !== null && _a2 !== void 0 ? _a2 : void 0;
      var email = (_b = object.email) !== null && _b !== void 0 ? _b : void 0;
      var phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : void 0;
      var photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : void 0;
      var tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : void 0;
      var _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : void 0;
      var createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : void 0;
      var lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : void 0;
      var uid = object.uid, emailVerified = object.emailVerified, isAnonymous = object.isAnonymous, providerData = object.providerData, plainObjectTokenManager = object.stsTokenManager;
      _assert(
        uid && plainObjectTokenManager,
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      var stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);
      _assert(
        typeof uid === "string",
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      assertStringOrUndefined(displayName, auth.name);
      assertStringOrUndefined(email, auth.name);
      _assert(
        typeof emailVerified === "boolean",
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      _assert(
        typeof isAnonymous === "boolean",
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      assertStringOrUndefined(phoneNumber, auth.name);
      assertStringOrUndefined(photoURL, auth.name);
      assertStringOrUndefined(tenantId, auth.name);
      assertStringOrUndefined(_redirectEventId, auth.name);
      assertStringOrUndefined(createdAt, auth.name);
      assertStringOrUndefined(lastLoginAt, auth.name);
      var user = new UserImpl2({
        uid,
        auth,
        email,
        emailVerified,
        displayName,
        isAnonymous,
        photoURL,
        phoneNumber,
        tenantId,
        stsTokenManager,
        createdAt,
        lastLoginAt
      });
      if (providerData && Array.isArray(providerData)) {
        user.providerData = providerData.map(function(userInfo) {
          return __assign({}, userInfo);
        });
      }
      if (_redirectEventId) {
        user._redirectEventId = _redirectEventId;
      }
      return user;
    };
    UserImpl2._fromIdTokenResponse = function(auth, idTokenResponse, isAnonymous) {
      if (isAnonymous === void 0) {
        isAnonymous = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        var stsTokenManager, user;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              stsTokenManager = new StsTokenManager();
              stsTokenManager.updateFromServerResponse(idTokenResponse);
              user = new UserImpl2({
                uid: idTokenResponse.localId,
                auth,
                stsTokenManager,
                isAnonymous
              });
              return [4, _reloadWithoutSaving(user)];
            case 1:
              _a2.sent();
              return [2, user];
          }
        });
      });
    };
    return UserImpl2;
  }()
);
var instanceCache = /* @__PURE__ */ new Map();
function _getInstance(cls) {
  debugAssert(cls instanceof Function, "Expected a class definition");
  var instance = instanceCache.get(cls);
  if (instance) {
    debugAssert(instance instanceof cls, "Instance stored in cache mismatched with class");
    return instance;
  }
  instance = new cls();
  instanceCache.set(cls, instance);
  return instance;
}
var InMemoryPersistence = (
  /** @class */
  function() {
    function InMemoryPersistence2() {
      this.type = "NONE";
      this.storage = {};
    }
    InMemoryPersistence2.prototype._isAvailable = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          return [2, true];
        });
      });
    };
    InMemoryPersistence2.prototype._set = function(key, value) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          this.storage[key] = value;
          return [
            2
            /*return*/
          ];
        });
      });
    };
    InMemoryPersistence2.prototype._get = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        var value;
        return __generator(this, function(_a2) {
          value = this.storage[key];
          return [2, value === void 0 ? null : value];
        });
      });
    };
    InMemoryPersistence2.prototype._remove = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          delete this.storage[key];
          return [
            2
            /*return*/
          ];
        });
      });
    };
    InMemoryPersistence2.prototype._addListener = function(_key, _listener) {
      return;
    };
    InMemoryPersistence2.prototype._removeListener = function(_key, _listener) {
      return;
    };
    InMemoryPersistence2.type = "NONE";
    return InMemoryPersistence2;
  }()
);
var inMemoryPersistence = InMemoryPersistence;
function _persistenceKeyName(key, apiKey, appName) {
  return "".concat("firebase", ":").concat(key, ":").concat(apiKey, ":").concat(appName);
}
var PersistenceUserManager = (
  /** @class */
  function() {
    function PersistenceUserManager2(persistence, auth, userKey) {
      this.persistence = persistence;
      this.auth = auth;
      this.userKey = userKey;
      var _a2 = this.auth, config = _a2.config, name2 = _a2.name;
      this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name2);
      this.fullPersistenceKey = _persistenceKeyName("persistence", config.apiKey, name2);
      this.boundEventHandler = auth._onStorageEvent.bind(auth);
      this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
    }
    PersistenceUserManager2.prototype.setCurrentUser = function(user) {
      return this.persistence._set(this.fullUserKey, user.toJSON());
    };
    PersistenceUserManager2.prototype.getCurrentUser = function() {
      return __awaiter(this, void 0, void 0, function() {
        var blob;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.persistence._get(this.fullUserKey)];
            case 1:
              blob = _a2.sent();
              return [2, blob ? UserImpl._fromJSON(this.auth, blob) : null];
          }
        });
      });
    };
    PersistenceUserManager2.prototype.removeCurrentUser = function() {
      return this.persistence._remove(this.fullUserKey);
    };
    PersistenceUserManager2.prototype.savePersistenceForRedirect = function() {
      return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
    };
    PersistenceUserManager2.prototype.setPersistence = function(newPersistence) {
      return __awaiter(this, void 0, void 0, function() {
        var currentUser;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (this.persistence === newPersistence) {
                return [
                  2
                  /*return*/
                ];
              }
              return [4, this.getCurrentUser()];
            case 1:
              currentUser = _a2.sent();
              return [4, this.removeCurrentUser()];
            case 2:
              _a2.sent();
              this.persistence = newPersistence;
              if (currentUser) {
                return [2, this.setCurrentUser(currentUser)];
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PersistenceUserManager2.prototype.delete = function() {
      this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
    };
    PersistenceUserManager2.create = function(auth, persistenceHierarchy, userKey) {
      if (userKey === void 0) {
        userKey = "authUser";
      }
      return __awaiter(this, void 0, void 0, function() {
        var availablePersistences, selectedPersistence, key, userToMigrate, _i, persistenceHierarchy_1, persistence, blob, user, migrationHierarchy;
        var _this = this;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!persistenceHierarchy.length) {
                return [2, new PersistenceUserManager2(_getInstance(inMemoryPersistence), auth, userKey)];
              }
              return [4, Promise.all(persistenceHierarchy.map(function(persistence2) {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_a2) {
                    switch (_a2.label) {
                      case 0:
                        return [4, persistence2._isAvailable()];
                      case 1:
                        if (_a2.sent()) {
                          return [2, persistence2];
                        }
                        return [2, void 0];
                    }
                  });
                });
              }))];
            case 1:
              availablePersistences = _b.sent().filter(function(persistence2) {
                return persistence2;
              });
              selectedPersistence = availablePersistences[0] || _getInstance(inMemoryPersistence);
              key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);
              userToMigrate = null;
              _i = 0, persistenceHierarchy_1 = persistenceHierarchy;
              _b.label = 2;
            case 2:
              if (!(_i < persistenceHierarchy_1.length))
                return [3, 7];
              persistence = persistenceHierarchy_1[_i];
              _b.label = 3;
            case 3:
              _b.trys.push([3, 5, , 6]);
              return [4, persistence._get(key)];
            case 4:
              blob = _b.sent();
              if (blob) {
                user = UserImpl._fromJSON(auth, blob);
                if (persistence !== selectedPersistence) {
                  userToMigrate = user;
                }
                selectedPersistence = persistence;
                return [3, 7];
              }
              return [3, 6];
            case 5:
              _b.sent();
              return [3, 6];
            case 6:
              _i++;
              return [3, 2];
            case 7:
              migrationHierarchy = availablePersistences.filter(function(p) {
                return p._shouldAllowMigration;
              });
              if (!selectedPersistence._shouldAllowMigration || !migrationHierarchy.length) {
                return [2, new PersistenceUserManager2(selectedPersistence, auth, userKey)];
              }
              selectedPersistence = migrationHierarchy[0];
              if (!userToMigrate)
                return [3, 9];
              return [4, selectedPersistence._set(key, userToMigrate.toJSON())];
            case 8:
              _b.sent();
              _b.label = 9;
            case 9:
              return [4, Promise.all(persistenceHierarchy.map(function(persistence2) {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_b2) {
                    switch (_b2.label) {
                      case 0:
                        if (!(persistence2 !== selectedPersistence))
                          return [3, 4];
                        _b2.label = 1;
                      case 1:
                        _b2.trys.push([1, 3, , 4]);
                        return [4, persistence2._remove(key)];
                      case 2:
                        _b2.sent();
                        return [3, 4];
                      case 3:
                        _b2.sent();
                        return [3, 4];
                      case 4:
                        return [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              }))];
            case 10:
              _b.sent();
              return [2, new PersistenceUserManager2(selectedPersistence, auth, userKey)];
          }
        });
      });
    };
    return PersistenceUserManager2;
  }()
);
function _getBrowserName(userAgent) {
  var ua = userAgent.toLowerCase();
  if (ua.includes("opera/") || ua.includes("opr/") || ua.includes("opios/")) {
    return "Opera";
  } else if (_isIEMobile(ua)) {
    return "IEMobile";
  } else if (ua.includes("msie") || ua.includes("trident/")) {
    return "IE";
  } else if (ua.includes("edge/")) {
    return "Edge";
  } else if (_isFirefox(ua)) {
    return "Firefox";
  } else if (ua.includes("silk/")) {
    return "Silk";
  } else if (_isBlackBerry(ua)) {
    return "Blackberry";
  } else if (_isWebOS(ua)) {
    return "Webos";
  } else if (_isSafari(ua)) {
    return "Safari";
  } else if ((ua.includes("chrome/") || _isChromeIOS(ua)) && !ua.includes("edge/")) {
    return "Chrome";
  } else if (_isAndroid(ua)) {
    return "Android";
  } else {
    var re = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/;
    var matches = userAgent.match(re);
    if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {
      return matches[1];
    }
  }
  return "Other";
}
function _isFirefox(ua) {
  if (ua === void 0) {
    ua = getUA();
  }
  return /firefox\//i.test(ua);
}
function _isSafari(userAgent) {
  if (userAgent === void 0) {
    userAgent = getUA();
  }
  var ua = userAgent.toLowerCase();
  return ua.includes("safari/") && !ua.includes("chrome/") && !ua.includes("crios/") && !ua.includes("android");
}
function _isChromeIOS(ua) {
  if (ua === void 0) {
    ua = getUA();
  }
  return /crios\//i.test(ua);
}
function _isIEMobile(ua) {
  if (ua === void 0) {
    ua = getUA();
  }
  return /iemobile/i.test(ua);
}
function _isAndroid(ua) {
  if (ua === void 0) {
    ua = getUA();
  }
  return /android/i.test(ua);
}
function _isBlackBerry(ua) {
  if (ua === void 0) {
    ua = getUA();
  }
  return /blackberry/i.test(ua);
}
function _isWebOS(ua) {
  if (ua === void 0) {
    ua = getUA();
  }
  return /webos/i.test(ua);
}
function _isIOS(ua) {
  if (ua === void 0) {
    ua = getUA();
  }
  return /iphone|ipad|ipod/i.test(ua) || /macintosh/i.test(ua) && /mobile/i.test(ua);
}
function _isIOS7Or8(ua) {
  if (ua === void 0) {
    ua = getUA();
  }
  return /(iPad|iPhone|iPod).*OS 7_\d/i.test(ua) || /(iPad|iPhone|iPod).*OS 8_\d/i.test(ua);
}
function _isIE10() {
  return isIE() && document.documentMode === 10;
}
function _isMobileBrowser(ua) {
  if (ua === void 0) {
    ua = getUA();
  }
  return _isIOS(ua) || _isAndroid(ua) || _isWebOS(ua) || _isBlackBerry(ua) || /windows phone/i.test(ua) || _isIEMobile(ua);
}
function _isIframe() {
  try {
    return !!(window && window !== window.top);
  } catch (e) {
    return false;
  }
}
function _getClientVersion(clientPlatform, frameworks) {
  if (frameworks === void 0) {
    frameworks = [];
  }
  var reportedPlatform;
  switch (clientPlatform) {
    case "Browser":
      reportedPlatform = _getBrowserName(getUA());
      break;
    case "Worker":
      reportedPlatform = "".concat(_getBrowserName(getUA()), "-").concat(clientPlatform);
      break;
    default:
      reportedPlatform = clientPlatform;
  }
  var reportedFrameworks = frameworks.length ? frameworks.join(",") : "FirebaseCore-web";
  return "".concat(reportedPlatform, "/").concat("JsCore", "/").concat(SDK_VERSION, "/").concat(reportedFrameworks);
}
var AuthMiddlewareQueue = (
  /** @class */
  function() {
    function AuthMiddlewareQueue2(auth) {
      this.auth = auth;
      this.queue = [];
    }
    AuthMiddlewareQueue2.prototype.pushCallback = function(callback, onAbort) {
      var _this = this;
      var wrappedCallback = function(user) {
        return new Promise(function(resolve, reject) {
          try {
            var result = callback(user);
            resolve(result);
          } catch (e) {
            reject(e);
          }
        });
      };
      wrappedCallback.onAbort = onAbort;
      this.queue.push(wrappedCallback);
      var index = this.queue.length - 1;
      return function() {
        _this.queue[index] = function() {
          return Promise.resolve();
        };
      };
    };
    AuthMiddlewareQueue2.prototype.runMiddleware = function(nextUser) {
      return __awaiter(this, void 0, void 0, function() {
        var onAbortStack, _i, _a2, beforeStateCallback, e_1, _b, onAbortStack_1, onAbort;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              if (this.auth.currentUser === nextUser) {
                return [
                  2
                  /*return*/
                ];
              }
              onAbortStack = [];
              _c.label = 1;
            case 1:
              _c.trys.push([1, 6, , 7]);
              _i = 0, _a2 = this.queue;
              _c.label = 2;
            case 2:
              if (!(_i < _a2.length))
                return [3, 5];
              beforeStateCallback = _a2[_i];
              return [4, beforeStateCallback(nextUser)];
            case 3:
              _c.sent();
              if (beforeStateCallback.onAbort) {
                onAbortStack.push(beforeStateCallback.onAbort);
              }
              _c.label = 4;
            case 4:
              _i++;
              return [3, 2];
            case 5:
              return [3, 7];
            case 6:
              e_1 = _c.sent();
              onAbortStack.reverse();
              for (_b = 0, onAbortStack_1 = onAbortStack; _b < onAbortStack_1.length; _b++) {
                onAbort = onAbortStack_1[_b];
                try {
                  onAbort();
                } catch (_) {
                }
              }
              throw this.auth._errorFactory.create("login-blocked", {
                originalMessage: e_1 === null || e_1 === void 0 ? void 0 : e_1.message
              });
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    return AuthMiddlewareQueue2;
  }()
);
function _getPasswordPolicy(auth, request) {
  if (request === void 0) {
    request = {};
  }
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "GET", "/v2/passwordPolicy", _addTidIfNecessary(auth, request))];
    });
  });
}
var MINIMUM_MIN_PASSWORD_LENGTH = 6;
var PasswordPolicyImpl = (
  /** @class */
  function() {
    function PasswordPolicyImpl2(response) {
      var _a2, _b, _c, _d;
      var responseOptions = response.customStrengthOptions;
      this.customStrengthOptions = {};
      this.customStrengthOptions.minPasswordLength = (_a2 = responseOptions.minPasswordLength) !== null && _a2 !== void 0 ? _a2 : MINIMUM_MIN_PASSWORD_LENGTH;
      if (responseOptions.maxPasswordLength) {
        this.customStrengthOptions.maxPasswordLength = responseOptions.maxPasswordLength;
      }
      if (responseOptions.containsLowercaseCharacter !== void 0) {
        this.customStrengthOptions.containsLowercaseLetter = responseOptions.containsLowercaseCharacter;
      }
      if (responseOptions.containsUppercaseCharacter !== void 0) {
        this.customStrengthOptions.containsUppercaseLetter = responseOptions.containsUppercaseCharacter;
      }
      if (responseOptions.containsNumericCharacter !== void 0) {
        this.customStrengthOptions.containsNumericCharacter = responseOptions.containsNumericCharacter;
      }
      if (responseOptions.containsNonAlphanumericCharacter !== void 0) {
        this.customStrengthOptions.containsNonAlphanumericCharacter = responseOptions.containsNonAlphanumericCharacter;
      }
      this.enforcementState = response.enforcementState;
      if (this.enforcementState === "ENFORCEMENT_STATE_UNSPECIFIED") {
        this.enforcementState = "OFF";
      }
      this.allowedNonAlphanumericCharacters = (_c = (_b = response.allowedNonAlphanumericCharacters) === null || _b === void 0 ? void 0 : _b.join("")) !== null && _c !== void 0 ? _c : "";
      this.forceUpgradeOnSignin = (_d = response.forceUpgradeOnSignin) !== null && _d !== void 0 ? _d : false;
      this.schemaVersion = response.schemaVersion;
    }
    PasswordPolicyImpl2.prototype.validatePassword = function(password) {
      var _a2, _b, _c, _d, _e, _f;
      var status = {
        isValid: true,
        passwordPolicy: this
      };
      this.validatePasswordLengthOptions(password, status);
      this.validatePasswordCharacterOptions(password, status);
      status.isValid && (status.isValid = (_a2 = status.meetsMinPasswordLength) !== null && _a2 !== void 0 ? _a2 : true);
      status.isValid && (status.isValid = (_b = status.meetsMaxPasswordLength) !== null && _b !== void 0 ? _b : true);
      status.isValid && (status.isValid = (_c = status.containsLowercaseLetter) !== null && _c !== void 0 ? _c : true);
      status.isValid && (status.isValid = (_d = status.containsUppercaseLetter) !== null && _d !== void 0 ? _d : true);
      status.isValid && (status.isValid = (_e = status.containsNumericCharacter) !== null && _e !== void 0 ? _e : true);
      status.isValid && (status.isValid = (_f = status.containsNonAlphanumericCharacter) !== null && _f !== void 0 ? _f : true);
      return status;
    };
    PasswordPolicyImpl2.prototype.validatePasswordLengthOptions = function(password, status) {
      var minPasswordLength = this.customStrengthOptions.minPasswordLength;
      var maxPasswordLength = this.customStrengthOptions.maxPasswordLength;
      if (minPasswordLength) {
        status.meetsMinPasswordLength = password.length >= minPasswordLength;
      }
      if (maxPasswordLength) {
        status.meetsMaxPasswordLength = password.length <= maxPasswordLength;
      }
    };
    PasswordPolicyImpl2.prototype.validatePasswordCharacterOptions = function(password, status) {
      this.updatePasswordCharacterOptionsStatuses(
        status,
        /* containsLowercaseCharacter= */
        false,
        /* containsUppercaseCharacter= */
        false,
        /* containsNumericCharacter= */
        false,
        /* containsNonAlphanumericCharacter= */
        false
      );
      var passwordChar;
      for (var i = 0; i < password.length; i++) {
        passwordChar = password.charAt(i);
        this.updatePasswordCharacterOptionsStatuses(
          status,
          /* containsLowercaseCharacter= */
          passwordChar >= "a" && passwordChar <= "z",
          /* containsUppercaseCharacter= */
          passwordChar >= "A" && passwordChar <= "Z",
          /* containsNumericCharacter= */
          passwordChar >= "0" && passwordChar <= "9",
          /* containsNonAlphanumericCharacter= */
          this.allowedNonAlphanumericCharacters.includes(passwordChar)
        );
      }
    };
    PasswordPolicyImpl2.prototype.updatePasswordCharacterOptionsStatuses = function(status, containsLowercaseCharacter, containsUppercaseCharacter, containsNumericCharacter, containsNonAlphanumericCharacter) {
      if (this.customStrengthOptions.containsLowercaseLetter) {
        status.containsLowercaseLetter || (status.containsLowercaseLetter = containsLowercaseCharacter);
      }
      if (this.customStrengthOptions.containsUppercaseLetter) {
        status.containsUppercaseLetter || (status.containsUppercaseLetter = containsUppercaseCharacter);
      }
      if (this.customStrengthOptions.containsNumericCharacter) {
        status.containsNumericCharacter || (status.containsNumericCharacter = containsNumericCharacter);
      }
      if (this.customStrengthOptions.containsNonAlphanumericCharacter) {
        status.containsNonAlphanumericCharacter || (status.containsNonAlphanumericCharacter = containsNonAlphanumericCharacter);
      }
    };
    return PasswordPolicyImpl2;
  }()
);
var AuthImpl = (
  /** @class */
  function() {
    function AuthImpl2(app, heartbeatServiceProvider, appCheckServiceProvider, config) {
      this.app = app;
      this.heartbeatServiceProvider = heartbeatServiceProvider;
      this.appCheckServiceProvider = appCheckServiceProvider;
      this.config = config;
      this.currentUser = null;
      this.emulatorConfig = null;
      this.operations = Promise.resolve();
      this.authStateSubscription = new Subscription(this);
      this.idTokenSubscription = new Subscription(this);
      this.beforeStateQueue = new AuthMiddlewareQueue(this);
      this.redirectUser = null;
      this.isProactiveRefreshEnabled = false;
      this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1;
      this._canInitEmulator = true;
      this._isInitialized = false;
      this._deleted = false;
      this._initializationPromise = null;
      this._popupRedirectResolver = null;
      this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;
      this._agentRecaptchaConfig = null;
      this._tenantRecaptchaConfigs = {};
      this._projectPasswordPolicy = null;
      this._tenantPasswordPolicies = {};
      this.lastNotifiedUid = void 0;
      this.languageCode = null;
      this.tenantId = null;
      this.settings = { appVerificationDisabledForTesting: false };
      this.frameworks = [];
      this.name = app.name;
      this.clientVersion = config.sdkClientVersion;
    }
    AuthImpl2.prototype._initializeWithPersistence = function(persistenceHierarchy, popupRedirectResolver) {
      var _this = this;
      if (popupRedirectResolver) {
        this._popupRedirectResolver = _getInstance(popupRedirectResolver);
      }
      this._initializationPromise = this.queue(function() {
        return __awaiter(_this, void 0, void 0, function() {
          var _a2;
          var _b, _c;
          return __generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (this._deleted) {
                  return [
                    2
                    /*return*/
                  ];
                }
                _a2 = this;
                return [4, PersistenceUserManager.create(this, persistenceHierarchy)];
              case 1:
                _a2.persistenceManager = _d.sent();
                if (this._deleted) {
                  return [
                    2
                    /*return*/
                  ];
                }
                if (!((_b = this._popupRedirectResolver) === null || _b === void 0 ? void 0 : _b._shouldInitProactively))
                  return [3, 5];
                _d.label = 2;
              case 2:
                _d.trys.push([2, 4, , 5]);
                return [4, this._popupRedirectResolver._initialize(this)];
              case 3:
                _d.sent();
                return [3, 5];
              case 4:
                _d.sent();
                return [3, 5];
              case 5:
                return [4, this.initializeCurrentUser(popupRedirectResolver)];
              case 6:
                _d.sent();
                this.lastNotifiedUid = ((_c = this.currentUser) === null || _c === void 0 ? void 0 : _c.uid) || null;
                if (this._deleted) {
                  return [
                    2
                    /*return*/
                  ];
                }
                this._isInitialized = true;
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
      return this._initializationPromise;
    };
    AuthImpl2.prototype._onStorageEvent = function() {
      return __awaiter(this, void 0, void 0, function() {
        var user;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (this._deleted) {
                return [
                  2
                  /*return*/
                ];
              }
              return [4, this.assertedPersistence.getCurrentUser()];
            case 1:
              user = _a2.sent();
              if (!this.currentUser && !user) {
                return [
                  2
                  /*return*/
                ];
              }
              if (!(this.currentUser && user && this.currentUser.uid === user.uid))
                return [3, 3];
              this._currentUser._assign(user);
              return [4, this.currentUser.getIdToken()];
            case 2:
              _a2.sent();
              return [
                2
                /*return*/
              ];
            case 3:
              return [4, this._updateCurrentUser(
                user,
                /* skipBeforeStateCallbacks */
                true
              )];
            case 4:
              _a2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    AuthImpl2.prototype.initializeCurrentUser = function(popupRedirectResolver) {
      var _a2;
      return __awaiter(this, void 0, void 0, function() {
        var previouslyStoredUser, futureCurrentUser, needsTocheckMiddleware, redirectUserEventId, storedUserEventId, result, e_2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, this.assertedPersistence.getCurrentUser()];
            case 1:
              previouslyStoredUser = _b.sent();
              futureCurrentUser = previouslyStoredUser;
              needsTocheckMiddleware = false;
              if (!(popupRedirectResolver && this.config.authDomain))
                return [3, 4];
              return [4, this.getOrInitRedirectPersistenceManager()];
            case 2:
              _b.sent();
              redirectUserEventId = (_a2 = this.redirectUser) === null || _a2 === void 0 ? void 0 : _a2._redirectEventId;
              storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;
              return [4, this.tryRedirectSignIn(popupRedirectResolver)];
            case 3:
              result = _b.sent();
              if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) && (result === null || result === void 0 ? void 0 : result.user)) {
                futureCurrentUser = result.user;
                needsTocheckMiddleware = true;
              }
              _b.label = 4;
            case 4:
              if (!futureCurrentUser) {
                return [2, this.directlySetCurrentUser(null)];
              }
              if (!!futureCurrentUser._redirectEventId)
                return [3, 9];
              if (!needsTocheckMiddleware)
                return [3, 8];
              _b.label = 5;
            case 5:
              _b.trys.push([5, 7, , 8]);
              return [4, this.beforeStateQueue.runMiddleware(futureCurrentUser)];
            case 6:
              _b.sent();
              return [3, 8];
            case 7:
              e_2 = _b.sent();
              futureCurrentUser = previouslyStoredUser;
              this._popupRedirectResolver._overrideRedirectResult(this, function() {
                return Promise.reject(e_2);
              });
              return [3, 8];
            case 8:
              if (futureCurrentUser) {
                return [2, this.reloadAndSetCurrentUserOrClear(futureCurrentUser)];
              } else {
                return [2, this.directlySetCurrentUser(null)];
              }
            case 9:
              _assert(
                this._popupRedirectResolver,
                this,
                "argument-error"
                /* AuthErrorCode.ARGUMENT_ERROR */
              );
              return [4, this.getOrInitRedirectPersistenceManager()];
            case 10:
              _b.sent();
              if (this.redirectUser && this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {
                return [2, this.directlySetCurrentUser(futureCurrentUser)];
              }
              return [2, this.reloadAndSetCurrentUserOrClear(futureCurrentUser)];
          }
        });
      });
    };
    AuthImpl2.prototype.tryRedirectSignIn = function(redirectResolver) {
      return __awaiter(this, void 0, void 0, function() {
        var result;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              result = null;
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 3, , 5]);
              return [4, this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true)];
            case 2:
              result = _a2.sent();
              return [3, 5];
            case 3:
              _a2.sent();
              return [4, this._setRedirectUser(null)];
            case 4:
              _a2.sent();
              return [3, 5];
            case 5:
              return [2, result];
          }
        });
      });
    };
    AuthImpl2.prototype.reloadAndSetCurrentUserOrClear = function(user) {
      return __awaiter(this, void 0, void 0, function() {
        var e_4;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, 2, , 3]);
              return [4, _reloadWithoutSaving(user)];
            case 1:
              _a2.sent();
              return [3, 3];
            case 2:
              e_4 = _a2.sent();
              if ((e_4 === null || e_4 === void 0 ? void 0 : e_4.code) !== "auth/".concat(
                "network-request-failed"
                /* AuthErrorCode.NETWORK_REQUEST_FAILED */
              )) {
                return [2, this.directlySetCurrentUser(null)];
              }
              return [3, 3];
            case 3:
              return [2, this.directlySetCurrentUser(user)];
          }
        });
      });
    };
    AuthImpl2.prototype.useDeviceLanguage = function() {
      this.languageCode = _getUserLanguage();
    };
    AuthImpl2.prototype._delete = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          this._deleted = true;
          return [
            2
            /*return*/
          ];
        });
      });
    };
    AuthImpl2.prototype.updateCurrentUser = function(userExtern) {
      return __awaiter(this, void 0, void 0, function() {
        var user;
        return __generator(this, function(_a2) {
          user = userExtern ? getModularInstance(userExtern) : null;
          if (user) {
            _assert(
              user.auth.config.apiKey === this.config.apiKey,
              this,
              "invalid-user-token"
              /* AuthErrorCode.INVALID_AUTH */
            );
          }
          return [2, this._updateCurrentUser(user && user._clone(this))];
        });
      });
    };
    AuthImpl2.prototype._updateCurrentUser = function(user, skipBeforeStateCallbacks) {
      if (skipBeforeStateCallbacks === void 0) {
        skipBeforeStateCallbacks = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (this._deleted) {
                return [
                  2
                  /*return*/
                ];
              }
              if (user) {
                _assert(
                  this.tenantId === user.tenantId,
                  this,
                  "tenant-id-mismatch"
                  /* AuthErrorCode.TENANT_ID_MISMATCH */
                );
              }
              if (!!skipBeforeStateCallbacks)
                return [3, 2];
              return [4, this.beforeStateQueue.runMiddleware(user)];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              return [2, this.queue(function() {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_a3) {
                    switch (_a3.label) {
                      case 0:
                        return [4, this.directlySetCurrentUser(user)];
                      case 1:
                        _a3.sent();
                        this.notifyAuthListeners();
                        return [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              })];
          }
        });
      });
    };
    AuthImpl2.prototype.signOut = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.beforeStateQueue.runMiddleware(null)];
            case 1:
              _a2.sent();
              if (!(this.redirectPersistenceManager || this._popupRedirectResolver))
                return [3, 3];
              return [4, this._setRedirectUser(null)];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              return [2, this._updateCurrentUser(
                null,
                /* skipBeforeStateCallbacks */
                true
              )];
          }
        });
      });
    };
    AuthImpl2.prototype.setPersistence = function(persistence) {
      var _this = this;
      return this.queue(function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.assertedPersistence.setPersistence(_getInstance(persistence))];
              case 1:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    };
    AuthImpl2.prototype._getRecaptchaConfig = function() {
      if (this.tenantId == null) {
        return this._agentRecaptchaConfig;
      } else {
        return this._tenantRecaptchaConfigs[this.tenantId];
      }
    };
    AuthImpl2.prototype.validatePassword = function(password) {
      return __awaiter(this, void 0, void 0, function() {
        var passwordPolicy;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!!this._getPasswordPolicyInternal())
                return [3, 2];
              return [4, this._updatePasswordPolicy()];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              passwordPolicy = this._getPasswordPolicyInternal();
              if (passwordPolicy.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION) {
                return [2, Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version", {}))];
              }
              return [2, passwordPolicy.validatePassword(password)];
          }
        });
      });
    };
    AuthImpl2.prototype._getPasswordPolicyInternal = function() {
      if (this.tenantId === null) {
        return this._projectPasswordPolicy;
      } else {
        return this._tenantPasswordPolicies[this.tenantId];
      }
    };
    AuthImpl2.prototype._updatePasswordPolicy = function() {
      return __awaiter(this, void 0, void 0, function() {
        var response, passwordPolicy;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, _getPasswordPolicy(this)];
            case 1:
              response = _a2.sent();
              passwordPolicy = new PasswordPolicyImpl(response);
              if (this.tenantId === null) {
                this._projectPasswordPolicy = passwordPolicy;
              } else {
                this._tenantPasswordPolicies[this.tenantId] = passwordPolicy;
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    AuthImpl2.prototype._getPersistence = function() {
      return this.assertedPersistence.persistence.type;
    };
    AuthImpl2.prototype._updateErrorMap = function(errorMap) {
      this._errorFactory = new ErrorFactory("auth", "Firebase", errorMap());
    };
    AuthImpl2.prototype.onAuthStateChanged = function(nextOrObserver, error, completed) {
      return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);
    };
    AuthImpl2.prototype.beforeAuthStateChanged = function(callback, onAbort) {
      return this.beforeStateQueue.pushCallback(callback, onAbort);
    };
    AuthImpl2.prototype.onIdTokenChanged = function(nextOrObserver, error, completed) {
      return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);
    };
    AuthImpl2.prototype.authStateReady = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        if (_this.currentUser) {
          resolve();
        } else {
          var unsubscribe_1 = _this.onAuthStateChanged(function() {
            unsubscribe_1();
            resolve();
          }, reject);
        }
      });
    };
    AuthImpl2.prototype.revokeAccessToken = function(token) {
      return __awaiter(this, void 0, void 0, function() {
        var idToken, request;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!this.currentUser)
                return [3, 3];
              return [4, this.currentUser.getIdToken()];
            case 1:
              idToken = _a2.sent();
              request = {
                providerId: "apple.com",
                tokenType: "ACCESS_TOKEN",
                token,
                idToken
              };
              if (this.tenantId != null) {
                request.tenantId = this.tenantId;
              }
              return [4, revokeToken(this, request)];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    AuthImpl2.prototype.toJSON = function() {
      var _a2;
      return {
        apiKey: this.config.apiKey,
        authDomain: this.config.authDomain,
        appName: this.name,
        currentUser: (_a2 = this._currentUser) === null || _a2 === void 0 ? void 0 : _a2.toJSON()
      };
    };
    AuthImpl2.prototype._setRedirectUser = function(user, popupRedirectResolver) {
      return __awaiter(this, void 0, void 0, function() {
        var redirectManager;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.getOrInitRedirectPersistenceManager(popupRedirectResolver)];
            case 1:
              redirectManager = _a2.sent();
              return [2, user === null ? redirectManager.removeCurrentUser() : redirectManager.setCurrentUser(user)];
          }
        });
      });
    };
    AuthImpl2.prototype.getOrInitRedirectPersistenceManager = function(popupRedirectResolver) {
      return __awaiter(this, void 0, void 0, function() {
        var resolver, _a2, _b;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              if (!!this.redirectPersistenceManager)
                return [3, 3];
              resolver = popupRedirectResolver && _getInstance(popupRedirectResolver) || this._popupRedirectResolver;
              _assert(
                resolver,
                this,
                "argument-error"
                /* AuthErrorCode.ARGUMENT_ERROR */
              );
              _a2 = this;
              return [4, PersistenceUserManager.create(
                this,
                [_getInstance(resolver._redirectPersistence)],
                "redirectUser"
                /* KeyName.REDIRECT_USER */
              )];
            case 1:
              _a2.redirectPersistenceManager = _c.sent();
              _b = this;
              return [4, this.redirectPersistenceManager.getCurrentUser()];
            case 2:
              _b.redirectUser = _c.sent();
              _c.label = 3;
            case 3:
              return [2, this.redirectPersistenceManager];
          }
        });
      });
    };
    AuthImpl2.prototype._redirectUserForId = function(id) {
      var _a2, _b;
      return __awaiter(this, void 0, void 0, function() {
        var _this = this;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              if (!this._isInitialized)
                return [3, 2];
              return [4, this.queue(function() {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_a3) {
                    return [
                      2
                      /*return*/
                    ];
                  });
                });
              })];
            case 1:
              _c.sent();
              _c.label = 2;
            case 2:
              if (((_a2 = this._currentUser) === null || _a2 === void 0 ? void 0 : _a2._redirectEventId) === id) {
                return [2, this._currentUser];
              }
              if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id) {
                return [2, this.redirectUser];
              }
              return [2, null];
          }
        });
      });
    };
    AuthImpl2.prototype._persistUserIfCurrent = function(user) {
      return __awaiter(this, void 0, void 0, function() {
        var _this = this;
        return __generator(this, function(_a2) {
          if (user === this.currentUser) {
            return [2, this.queue(function() {
              return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a3) {
                  return [2, this.directlySetCurrentUser(user)];
                });
              });
            })];
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    AuthImpl2.prototype._notifyListenersIfCurrent = function(user) {
      if (user === this.currentUser) {
        this.notifyAuthListeners();
      }
    };
    AuthImpl2.prototype._key = function() {
      return "".concat(this.config.authDomain, ":").concat(this.config.apiKey, ":").concat(this.name);
    };
    AuthImpl2.prototype._startProactiveRefresh = function() {
      this.isProactiveRefreshEnabled = true;
      if (this.currentUser) {
        this._currentUser._startProactiveRefresh();
      }
    };
    AuthImpl2.prototype._stopProactiveRefresh = function() {
      this.isProactiveRefreshEnabled = false;
      if (this.currentUser) {
        this._currentUser._stopProactiveRefresh();
      }
    };
    Object.defineProperty(AuthImpl2.prototype, "_currentUser", {
      /** Returns the current user cast as the internal type */
      get: function() {
        return this.currentUser;
      },
      enumerable: false,
      configurable: true
    });
    AuthImpl2.prototype.notifyAuthListeners = function() {
      var _a2, _b;
      if (!this._isInitialized) {
        return;
      }
      this.idTokenSubscription.next(this.currentUser);
      var currentUid = (_b = (_a2 = this.currentUser) === null || _a2 === void 0 ? void 0 : _a2.uid) !== null && _b !== void 0 ? _b : null;
      if (this.lastNotifiedUid !== currentUid) {
        this.lastNotifiedUid = currentUid;
        this.authStateSubscription.next(this.currentUser);
      }
    };
    AuthImpl2.prototype.registerStateListener = function(subscription, nextOrObserver, error, completed) {
      var _this = this;
      if (this._deleted) {
        return function() {
        };
      }
      var cb = typeof nextOrObserver === "function" ? nextOrObserver : nextOrObserver.next.bind(nextOrObserver);
      var isUnsubscribed = false;
      var promise = this._isInitialized ? Promise.resolve() : this._initializationPromise;
      _assert(
        promise,
        this,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      promise.then(function() {
        if (isUnsubscribed) {
          return;
        }
        cb(_this.currentUser);
      });
      if (typeof nextOrObserver === "function") {
        var unsubscribe_2 = subscription.addObserver(nextOrObserver, error, completed);
        return function() {
          isUnsubscribed = true;
          unsubscribe_2();
        };
      } else {
        var unsubscribe_3 = subscription.addObserver(nextOrObserver);
        return function() {
          isUnsubscribed = true;
          unsubscribe_3();
        };
      }
    };
    AuthImpl2.prototype.directlySetCurrentUser = function(user) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (this.currentUser && this.currentUser !== user) {
                this._currentUser._stopProactiveRefresh();
              }
              if (user && this.isProactiveRefreshEnabled) {
                user._startProactiveRefresh();
              }
              this.currentUser = user;
              if (!user)
                return [3, 2];
              return [4, this.assertedPersistence.setCurrentUser(user)];
            case 1:
              _a2.sent();
              return [3, 4];
            case 2:
              return [4, this.assertedPersistence.removeCurrentUser()];
            case 3:
              _a2.sent();
              _a2.label = 4;
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    AuthImpl2.prototype.queue = function(action) {
      this.operations = this.operations.then(action, action);
      return this.operations;
    };
    Object.defineProperty(AuthImpl2.prototype, "assertedPersistence", {
      get: function() {
        _assert(
          this.persistenceManager,
          this,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
        return this.persistenceManager;
      },
      enumerable: false,
      configurable: true
    });
    AuthImpl2.prototype._logFramework = function(framework) {
      if (!framework || this.frameworks.includes(framework)) {
        return;
      }
      this.frameworks.push(framework);
      this.frameworks.sort();
      this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());
    };
    AuthImpl2.prototype._getFrameworks = function() {
      return this.frameworks;
    };
    AuthImpl2.prototype._getAdditionalHeaders = function() {
      var _a2;
      return __awaiter(this, void 0, void 0, function() {
        var headers, heartbeatsHeader, appCheckToken;
        var _b;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              headers = (_b = {}, _b[
                "X-Client-Version"
                /* HttpHeader.X_CLIENT_VERSION */
              ] = this.clientVersion, _b);
              if (this.app.options.appId) {
                headers[
                  "X-Firebase-gmpid"
                  /* HttpHeader.X_FIREBASE_GMPID */
                ] = this.app.options.appId;
              }
              return [4, (_a2 = this.heartbeatServiceProvider.getImmediate({
                optional: true
              })) === null || _a2 === void 0 ? void 0 : _a2.getHeartbeatsHeader()];
            case 1:
              heartbeatsHeader = _c.sent();
              if (heartbeatsHeader) {
                headers[
                  "X-Firebase-Client"
                  /* HttpHeader.X_FIREBASE_CLIENT */
                ] = heartbeatsHeader;
              }
              return [4, this._getAppCheckToken()];
            case 2:
              appCheckToken = _c.sent();
              if (appCheckToken) {
                headers[
                  "X-Firebase-AppCheck"
                  /* HttpHeader.X_FIREBASE_APP_CHECK */
                ] = appCheckToken;
              }
              return [2, headers];
          }
        });
      });
    };
    AuthImpl2.prototype._getAppCheckToken = function() {
      var _a2;
      return __awaiter(this, void 0, void 0, function() {
        var appCheckTokenResult;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, (_a2 = this.appCheckServiceProvider.getImmediate({ optional: true })) === null || _a2 === void 0 ? void 0 : _a2.getToken()];
            case 1:
              appCheckTokenResult = _b.sent();
              if (appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.error) {
                _logWarn("Error while retrieving App Check token: ".concat(appCheckTokenResult.error));
              }
              return [2, appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.token];
          }
        });
      });
    };
    return AuthImpl2;
  }()
);
function _castAuth(auth) {
  return getModularInstance(auth);
}
var Subscription = (
  /** @class */
  function() {
    function Subscription2(auth) {
      var _this = this;
      this.auth = auth;
      this.observer = null;
      this.addObserver = createSubscribe(function(observer) {
        return _this.observer = observer;
      });
    }
    Object.defineProperty(Subscription2.prototype, "next", {
      get: function() {
        _assert(
          this.observer,
          this.auth,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
        return this.observer.next.bind(this.observer);
      },
      enumerable: false,
      configurable: true
    });
    return Subscription2;
  }()
);
function getScriptParentElement() {
  var _a2, _b;
  return (_b = (_a2 = document.getElementsByTagName("head")) === null || _a2 === void 0 ? void 0 : _a2[0]) !== null && _b !== void 0 ? _b : document;
}
function _loadJS(url) {
  return new Promise(function(resolve, reject) {
    var el = document.createElement("script");
    el.setAttribute("src", url);
    el.onload = resolve;
    el.onerror = function(e) {
      var error = _createError(
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      error.customData = e;
      reject(error);
    };
    el.type = "text/javascript";
    el.charset = "UTF-8";
    getScriptParentElement().appendChild(el);
  });
}
var RECAPTCHA_ENTERPRISE_URL = "https://www.google.com/recaptcha/enterprise.js?render=";
var RECAPTCHA_ENTERPRISE_VERIFIER_TYPE = "recaptcha-enterprise";
var FAKE_TOKEN = "NO_RECAPTCHA";
var RecaptchaEnterpriseVerifier = (
  /** @class */
  function() {
    function RecaptchaEnterpriseVerifier2(authExtern) {
      this.type = RECAPTCHA_ENTERPRISE_VERIFIER_TYPE;
      this.auth = _castAuth(authExtern);
    }
    RecaptchaEnterpriseVerifier2.prototype.verify = function(action, forceRefresh) {
      if (action === void 0) {
        action = "verify";
      }
      if (forceRefresh === void 0) {
        forceRefresh = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        function retrieveSiteKey(auth) {
          return __awaiter(this, void 0, void 0, function() {
            var _this2 = this;
            return __generator(this, function(_a2) {
              if (!forceRefresh) {
                if (auth.tenantId == null && auth._agentRecaptchaConfig != null) {
                  return [2, auth._agentRecaptchaConfig.siteKey];
                }
                if (auth.tenantId != null && auth._tenantRecaptchaConfigs[auth.tenantId] !== void 0) {
                  return [2, auth._tenantRecaptchaConfigs[auth.tenantId].siteKey];
                }
              }
              return [2, new Promise(function(resolve, reject) {
                return __awaiter(_this2, void 0, void 0, function() {
                  return __generator(this, function(_a3) {
                    getRecaptchaConfig(auth, {
                      clientType: "CLIENT_TYPE_WEB",
                      version: "RECAPTCHA_ENTERPRISE"
                      /* RecaptchaVersion.ENTERPRISE */
                    }).then(function(response) {
                      if (response.recaptchaKey === void 0) {
                        reject(new Error("recaptcha Enterprise site key undefined"));
                      } else {
                        var config = new RecaptchaConfig(response);
                        if (auth.tenantId == null) {
                          auth._agentRecaptchaConfig = config;
                        } else {
                          auth._tenantRecaptchaConfigs[auth.tenantId] = config;
                        }
                        return resolve(config.siteKey);
                      }
                    }).catch(function(error) {
                      reject(error);
                    });
                    return [
                      2
                      /*return*/
                    ];
                  });
                });
              })];
            });
          });
        }
        function retrieveRecaptchaToken(siteKey, resolve, reject) {
          var grecaptcha = window.grecaptcha;
          if (isEnterprise(grecaptcha)) {
            grecaptcha.enterprise.ready(function() {
              grecaptcha.enterprise.execute(siteKey, { action }).then(function(token) {
                resolve(token);
              }).catch(function() {
                resolve(FAKE_TOKEN);
              });
            });
          } else {
            reject(Error("No reCAPTCHA enterprise script loaded."));
          }
        }
        var _this = this;
        return __generator(this, function(_a2) {
          return [2, new Promise(function(resolve, reject) {
            retrieveSiteKey(_this.auth).then(function(siteKey) {
              if (!forceRefresh && isEnterprise(window.grecaptcha)) {
                retrieveRecaptchaToken(siteKey, resolve, reject);
              } else {
                if (typeof window === "undefined") {
                  reject(new Error("RecaptchaVerifier is only supported in browser"));
                  return;
                }
                _loadJS(RECAPTCHA_ENTERPRISE_URL + siteKey).then(function() {
                  retrieveRecaptchaToken(siteKey, resolve, reject);
                }).catch(function(error) {
                  reject(error);
                });
              }
            }).catch(function(error) {
              reject(error);
            });
          })];
        });
      });
    };
    return RecaptchaEnterpriseVerifier2;
  }()
);
function injectRecaptchaFields(auth, request, action, captchaResp) {
  if (captchaResp === void 0) {
    captchaResp = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var verifier, captchaResponse, newRequest;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          verifier = new RecaptchaEnterpriseVerifier(auth);
          _a2.label = 1;
        case 1:
          _a2.trys.push([1, 3, , 5]);
          return [4, verifier.verify(action)];
        case 2:
          captchaResponse = _a2.sent();
          return [3, 5];
        case 3:
          _a2.sent();
          return [4, verifier.verify(action, true)];
        case 4:
          captchaResponse = _a2.sent();
          return [3, 5];
        case 5:
          newRequest = __assign({}, request);
          if (!captchaResp) {
            Object.assign(newRequest, { captchaResponse });
          } else {
            Object.assign(newRequest, { "captchaResp": captchaResponse });
          }
          Object.assign(newRequest, {
            "clientType": "CLIENT_TYPE_WEB"
            /* RecaptchaClientType.WEB */
          });
          Object.assign(newRequest, {
            "recaptchaVersion": "RECAPTCHA_ENTERPRISE"
            /* RecaptchaVersion.ENTERPRISE */
          });
          return [2, newRequest];
      }
    });
  });
}
function handleRecaptchaFlow(authInstance, request, actionName, actionMethod) {
  var _a2;
  return __awaiter(this, void 0, void 0, function() {
    var requestWithRecaptcha;
    var _this = this;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          if (!((_a2 = authInstance._getRecaptchaConfig()) === null || _a2 === void 0 ? void 0 : _a2.isProviderEnabled(
            "EMAIL_PASSWORD_PROVIDER"
            /* RecaptchaProvider.EMAIL_PASSWORD_PROVIDER */
          )))
            return [3, 2];
          return [4, injectRecaptchaFields(
            authInstance,
            request,
            actionName,
            actionName === "getOobCode"
            /* RecaptchaActionName.GET_OOB_CODE */
          )];
        case 1:
          requestWithRecaptcha = _b.sent();
          return [2, actionMethod(authInstance, requestWithRecaptcha)];
        case 2:
          return [2, actionMethod(authInstance, request).catch(function(error) {
            return __awaiter(_this, void 0, void 0, function() {
              var requestWithRecaptcha2;
              return __generator(this, function(_a3) {
                switch (_a3.label) {
                  case 0:
                    if (!(error.code === "auth/".concat(
                      "missing-recaptcha-token"
                      /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */
                    )))
                      return [3, 2];
                    console.log("".concat(actionName, " is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow."));
                    return [4, injectRecaptchaFields(
                      authInstance,
                      request,
                      actionName,
                      actionName === "getOobCode"
                      /* RecaptchaActionName.GET_OOB_CODE */
                    )];
                  case 1:
                    requestWithRecaptcha2 = _a3.sent();
                    return [2, actionMethod(authInstance, requestWithRecaptcha2)];
                  case 2:
                    return [2, Promise.reject(error)];
                }
              });
            });
          })];
      }
    });
  });
}
function _initializeRecaptchaConfig(auth) {
  return __awaiter(this, void 0, void 0, function() {
    var authInternal, response, config, verifier;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          authInternal = _castAuth(auth);
          return [4, getRecaptchaConfig(authInternal, {
            clientType: "CLIENT_TYPE_WEB",
            version: "RECAPTCHA_ENTERPRISE"
            /* RecaptchaVersion.ENTERPRISE */
          })];
        case 1:
          response = _a2.sent();
          config = new RecaptchaConfig(response);
          if (authInternal.tenantId == null) {
            authInternal._agentRecaptchaConfig = config;
          } else {
            authInternal._tenantRecaptchaConfigs[authInternal.tenantId] = config;
          }
          if (config.isProviderEnabled(
            "EMAIL_PASSWORD_PROVIDER"
            /* RecaptchaProvider.EMAIL_PASSWORD_PROVIDER */
          )) {
            verifier = new RecaptchaEnterpriseVerifier(authInternal);
            void verifier.verify();
          }
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function initializeAuth(app, deps) {
  var provider = _getProvider(app, "auth");
  if (provider.isInitialized()) {
    var auth_1 = provider.getImmediate();
    var initialOptions = provider.getOptions();
    if (deepEqual(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {
      return auth_1;
    } else {
      _fail(
        auth_1,
        "already-initialized"
        /* AuthErrorCode.ALREADY_INITIALIZED */
      );
    }
  }
  var auth = provider.initialize({ options: deps });
  return auth;
}
function _initializeAuthInstance(auth, deps) {
  var persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];
  var hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);
  if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {
    auth._updateErrorMap(deps.errorMap);
  }
  auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);
}
function connectAuthEmulator(auth, url, options) {
  var authInternal = _castAuth(auth);
  _assert(
    authInternal._canInitEmulator,
    authInternal,
    "emulator-config-failed"
    /* AuthErrorCode.EMULATOR_CONFIG_FAILED */
  );
  _assert(
    /^https?:\/\//.test(url),
    authInternal,
    "invalid-emulator-scheme"
    /* AuthErrorCode.INVALID_EMULATOR_SCHEME */
  );
  var disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);
  var protocol = extractProtocol(url);
  var _a2 = extractHostAndPort(url), host = _a2.host, port = _a2.port;
  var portStr = port === null ? "" : ":".concat(port);
  authInternal.config.emulator = { url: "".concat(protocol, "//").concat(host).concat(portStr, "/") };
  authInternal.settings.appVerificationDisabledForTesting = true;
  authInternal.emulatorConfig = Object.freeze({
    host,
    port,
    protocol: protocol.replace(":", ""),
    options: Object.freeze({ disableWarnings })
  });
  if (!disableWarnings) {
    emitEmulatorWarning();
  }
}
function extractProtocol(url) {
  var protocolEnd = url.indexOf(":");
  return protocolEnd < 0 ? "" : url.substr(0, protocolEnd + 1);
}
function extractHostAndPort(url) {
  var protocol = extractProtocol(url);
  var authority = /(\/\/)?([^?#/]+)/.exec(url.substr(protocol.length));
  if (!authority) {
    return { host: "", port: null };
  }
  var hostAndPort = authority[2].split("@").pop() || "";
  var bracketedIPv6 = /^(\[[^\]]+\])(:|$)/.exec(hostAndPort);
  if (bracketedIPv6) {
    var host = bracketedIPv6[1];
    return { host, port: parsePort(hostAndPort.substr(host.length + 1)) };
  } else {
    var _a2 = hostAndPort.split(":"), host = _a2[0], port = _a2[1];
    return { host, port: parsePort(port) };
  }
}
function parsePort(portStr) {
  if (!portStr) {
    return null;
  }
  var port = Number(portStr);
  if (isNaN(port)) {
    return null;
  }
  return port;
}
function emitEmulatorWarning() {
  function attachBanner() {
    var el = document.createElement("p");
    var sty = el.style;
    el.innerText = "Running in emulator mode. Do not use with production credentials.";
    sty.position = "fixed";
    sty.width = "100%";
    sty.backgroundColor = "#ffffff";
    sty.border = ".1em solid #000000";
    sty.color = "#b50000";
    sty.bottom = "0px";
    sty.left = "0px";
    sty.margin = "0px";
    sty.zIndex = "10000";
    sty.textAlign = "center";
    el.classList.add("firebase-emulator-warning");
    document.body.appendChild(el);
  }
  if (typeof console !== "undefined" && typeof console.info === "function") {
    console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");
  }
  if (typeof window !== "undefined" && typeof document !== "undefined") {
    if (document.readyState === "loading") {
      window.addEventListener("DOMContentLoaded", attachBanner);
    } else {
      attachBanner();
    }
  }
}
var AuthCredential = (
  /** @class */
  function() {
    function AuthCredential2(providerId, signInMethod) {
      this.providerId = providerId;
      this.signInMethod = signInMethod;
    }
    AuthCredential2.prototype.toJSON = function() {
      return debugFail("not implemented");
    };
    AuthCredential2.prototype._getIdTokenResponse = function(_auth) {
      return debugFail("not implemented");
    };
    AuthCredential2.prototype._linkToIdToken = function(_auth, _idToken) {
      return debugFail("not implemented");
    };
    AuthCredential2.prototype._getReauthenticationResolver = function(_auth) {
      return debugFail("not implemented");
    };
    return AuthCredential2;
  }()
);
function resetPassword(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "POST", "/v1/accounts:resetPassword", _addTidIfNecessary(auth, request))];
    });
  });
}
function updateEmailPassword(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "POST", "/v1/accounts:update", request)];
    });
  });
}
function linkEmailPassword(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "POST", "/v1/accounts:signUp", request)];
    });
  });
}
function applyActionCode$1(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "POST", "/v1/accounts:update", _addTidIfNecessary(auth, request))];
    });
  });
}
function signInWithPassword(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performSignInRequest(auth, "POST", "/v1/accounts:signInWithPassword", _addTidIfNecessary(auth, request))];
    });
  });
}
function sendOobCode(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "POST", "/v1/accounts:sendOobCode", _addTidIfNecessary(auth, request))];
    });
  });
}
function sendEmailVerification$1(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, sendOobCode(auth, request)];
    });
  });
}
function sendPasswordResetEmail$1(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, sendOobCode(auth, request)];
    });
  });
}
function sendSignInLinkToEmail$1(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, sendOobCode(auth, request)];
    });
  });
}
function verifyAndChangeEmail(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, sendOobCode(auth, request)];
    });
  });
}
function signInWithEmailLink$1(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performSignInRequest(auth, "POST", "/v1/accounts:signInWithEmailLink", _addTidIfNecessary(auth, request))];
    });
  });
}
function signInWithEmailLinkForLinking(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performSignInRequest(auth, "POST", "/v1/accounts:signInWithEmailLink", _addTidIfNecessary(auth, request))];
    });
  });
}
var EmailAuthCredential = (
  /** @class */
  function(_super) {
    __extends(EmailAuthCredential2, _super);
    function EmailAuthCredential2(_email, _password, signInMethod, _tenantId) {
      if (_tenantId === void 0) {
        _tenantId = null;
      }
      var _this = _super.call(this, "password", signInMethod) || this;
      _this._email = _email;
      _this._password = _password;
      _this._tenantId = _tenantId;
      return _this;
    }
    EmailAuthCredential2._fromEmailAndPassword = function(email, password) {
      return new EmailAuthCredential2(
        email,
        password,
        "password"
        /* SignInMethod.EMAIL_PASSWORD */
      );
    };
    EmailAuthCredential2._fromEmailAndCode = function(email, oobCode, tenantId) {
      if (tenantId === void 0) {
        tenantId = null;
      }
      return new EmailAuthCredential2(email, oobCode, "emailLink", tenantId);
    };
    EmailAuthCredential2.prototype.toJSON = function() {
      return {
        email: this._email,
        password: this._password,
        signInMethod: this.signInMethod,
        tenantId: this._tenantId
      };
    };
    EmailAuthCredential2.fromJSON = function(json) {
      var obj = typeof json === "string" ? JSON.parse(json) : json;
      if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {
        if (obj.signInMethod === "password") {
          return this._fromEmailAndPassword(obj.email, obj.password);
        } else if (obj.signInMethod === "emailLink") {
          return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);
        }
      }
      return null;
    };
    EmailAuthCredential2.prototype._getIdTokenResponse = function(auth) {
      return __awaiter(this, void 0, void 0, function() {
        var request;
        return __generator(this, function(_a2) {
          switch (this.signInMethod) {
            case "password":
              request = {
                returnSecureToken: true,
                email: this._email,
                password: this._password,
                clientType: "CLIENT_TYPE_WEB"
                /* RecaptchaClientType.WEB */
              };
              return [2, handleRecaptchaFlow(auth, request, "signInWithPassword", signInWithPassword)];
            case "emailLink":
              return [2, signInWithEmailLink$1(auth, {
                email: this._email,
                oobCode: this._password
              })];
            default:
              _fail(
                auth,
                "internal-error"
                /* AuthErrorCode.INTERNAL_ERROR */
              );
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    EmailAuthCredential2.prototype._linkToIdToken = function(auth, idToken) {
      return __awaiter(this, void 0, void 0, function() {
        var request;
        return __generator(this, function(_a2) {
          switch (this.signInMethod) {
            case "password":
              request = {
                idToken,
                returnSecureToken: true,
                email: this._email,
                password: this._password,
                clientType: "CLIENT_TYPE_WEB"
                /* RecaptchaClientType.WEB */
              };
              return [2, handleRecaptchaFlow(auth, request, "signUpPassword", linkEmailPassword)];
            case "emailLink":
              return [2, signInWithEmailLinkForLinking(auth, {
                idToken,
                email: this._email,
                oobCode: this._password
              })];
            default:
              _fail(
                auth,
                "internal-error"
                /* AuthErrorCode.INTERNAL_ERROR */
              );
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    EmailAuthCredential2.prototype._getReauthenticationResolver = function(auth) {
      return this._getIdTokenResponse(auth);
    };
    return EmailAuthCredential2;
  }(AuthCredential)
);
function signInWithIdp(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performSignInRequest(auth, "POST", "/v1/accounts:signInWithIdp", _addTidIfNecessary(auth, request))];
    });
  });
}
var IDP_REQUEST_URI$1 = "http://localhost";
var OAuthCredential = (
  /** @class */
  function(_super) {
    __extends(OAuthCredential2, _super);
    function OAuthCredential2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.pendingToken = null;
      return _this;
    }
    OAuthCredential2._fromParams = function(params) {
      var cred = new OAuthCredential2(params.providerId, params.signInMethod);
      if (params.idToken || params.accessToken) {
        if (params.idToken) {
          cred.idToken = params.idToken;
        }
        if (params.accessToken) {
          cred.accessToken = params.accessToken;
        }
        if (params.nonce && !params.pendingToken) {
          cred.nonce = params.nonce;
        }
        if (params.pendingToken) {
          cred.pendingToken = params.pendingToken;
        }
      } else if (params.oauthToken && params.oauthTokenSecret) {
        cred.accessToken = params.oauthToken;
        cred.secret = params.oauthTokenSecret;
      } else {
        _fail(
          "argument-error"
          /* AuthErrorCode.ARGUMENT_ERROR */
        );
      }
      return cred;
    };
    OAuthCredential2.prototype.toJSON = function() {
      return {
        idToken: this.idToken,
        accessToken: this.accessToken,
        secret: this.secret,
        nonce: this.nonce,
        pendingToken: this.pendingToken,
        providerId: this.providerId,
        signInMethod: this.signInMethod
      };
    };
    OAuthCredential2.fromJSON = function(json) {
      var obj = typeof json === "string" ? JSON.parse(json) : json;
      var providerId = obj.providerId, signInMethod = obj.signInMethod, rest = __rest(obj, ["providerId", "signInMethod"]);
      if (!providerId || !signInMethod) {
        return null;
      }
      var cred = new OAuthCredential2(providerId, signInMethod);
      cred.idToken = rest.idToken || void 0;
      cred.accessToken = rest.accessToken || void 0;
      cred.secret = rest.secret;
      cred.nonce = rest.nonce;
      cred.pendingToken = rest.pendingToken || null;
      return cred;
    };
    OAuthCredential2.prototype._getIdTokenResponse = function(auth) {
      var request = this.buildRequest();
      return signInWithIdp(auth, request);
    };
    OAuthCredential2.prototype._linkToIdToken = function(auth, idToken) {
      var request = this.buildRequest();
      request.idToken = idToken;
      return signInWithIdp(auth, request);
    };
    OAuthCredential2.prototype._getReauthenticationResolver = function(auth) {
      var request = this.buildRequest();
      request.autoCreate = false;
      return signInWithIdp(auth, request);
    };
    OAuthCredential2.prototype.buildRequest = function() {
      var request = {
        requestUri: IDP_REQUEST_URI$1,
        returnSecureToken: true
      };
      if (this.pendingToken) {
        request.pendingToken = this.pendingToken;
      } else {
        var postBody = {};
        if (this.idToken) {
          postBody["id_token"] = this.idToken;
        }
        if (this.accessToken) {
          postBody["access_token"] = this.accessToken;
        }
        if (this.secret) {
          postBody["oauth_token_secret"] = this.secret;
        }
        postBody["providerId"] = this.providerId;
        if (this.nonce && !this.pendingToken) {
          postBody["nonce"] = this.nonce;
        }
        request.postBody = querystring(postBody);
      }
      return request;
    };
    return OAuthCredential2;
  }(AuthCredential)
);
var _a;
function signInWithPhoneNumber(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performSignInRequest(auth, "POST", "/v1/accounts:signInWithPhoneNumber", _addTidIfNecessary(auth, request))];
    });
  });
}
function linkWithPhoneNumber(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    var response;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, _performSignInRequest(auth, "POST", "/v1/accounts:signInWithPhoneNumber", _addTidIfNecessary(auth, request))];
        case 1:
          response = _a2.sent();
          if (response.temporaryProof) {
            throw _makeTaggedError(auth, "account-exists-with-different-credential", response);
          }
          return [2, response];
      }
    });
  });
}
var VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = (_a = {}, _a[
  "USER_NOT_FOUND"
  /* ServerError.USER_NOT_FOUND */
] = "user-not-found", _a);
function verifyPhoneNumberForExisting(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    var apiRequest;
    return __generator(this, function(_a2) {
      apiRequest = __assign(__assign({}, request), { operation: "REAUTH" });
      return [2, _performSignInRequest(auth, "POST", "/v1/accounts:signInWithPhoneNumber", _addTidIfNecessary(auth, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_)];
    });
  });
}
var PhoneAuthCredential = (
  /** @class */
  function(_super) {
    __extends(PhoneAuthCredential2, _super);
    function PhoneAuthCredential2(params) {
      var _this = _super.call(
        this,
        "phone",
        "phone"
        /* SignInMethod.PHONE */
      ) || this;
      _this.params = params;
      return _this;
    }
    PhoneAuthCredential2._fromVerification = function(verificationId, verificationCode) {
      return new PhoneAuthCredential2({ verificationId, verificationCode });
    };
    PhoneAuthCredential2._fromTokenResponse = function(phoneNumber, temporaryProof) {
      return new PhoneAuthCredential2({ phoneNumber, temporaryProof });
    };
    PhoneAuthCredential2.prototype._getIdTokenResponse = function(auth) {
      return signInWithPhoneNumber(auth, this._makeVerificationRequest());
    };
    PhoneAuthCredential2.prototype._linkToIdToken = function(auth, idToken) {
      return linkWithPhoneNumber(auth, __assign({ idToken }, this._makeVerificationRequest()));
    };
    PhoneAuthCredential2.prototype._getReauthenticationResolver = function(auth) {
      return verifyPhoneNumberForExisting(auth, this._makeVerificationRequest());
    };
    PhoneAuthCredential2.prototype._makeVerificationRequest = function() {
      var _a2 = this.params, temporaryProof = _a2.temporaryProof, phoneNumber = _a2.phoneNumber, verificationId = _a2.verificationId, verificationCode = _a2.verificationCode;
      if (temporaryProof && phoneNumber) {
        return { temporaryProof, phoneNumber };
      }
      return {
        sessionInfo: verificationId,
        code: verificationCode
      };
    };
    PhoneAuthCredential2.prototype.toJSON = function() {
      var obj = {
        providerId: this.providerId
      };
      if (this.params.phoneNumber) {
        obj.phoneNumber = this.params.phoneNumber;
      }
      if (this.params.temporaryProof) {
        obj.temporaryProof = this.params.temporaryProof;
      }
      if (this.params.verificationCode) {
        obj.verificationCode = this.params.verificationCode;
      }
      if (this.params.verificationId) {
        obj.verificationId = this.params.verificationId;
      }
      return obj;
    };
    PhoneAuthCredential2.fromJSON = function(json) {
      if (typeof json === "string") {
        json = JSON.parse(json);
      }
      var _a2 = json, verificationId = _a2.verificationId, verificationCode = _a2.verificationCode, phoneNumber = _a2.phoneNumber, temporaryProof = _a2.temporaryProof;
      if (!verificationCode && !verificationId && !phoneNumber && !temporaryProof) {
        return null;
      }
      return new PhoneAuthCredential2({
        verificationId,
        verificationCode,
        phoneNumber,
        temporaryProof
      });
    };
    return PhoneAuthCredential2;
  }(AuthCredential)
);
function parseMode(mode) {
  switch (mode) {
    case "recoverEmail":
      return "RECOVER_EMAIL";
    case "resetPassword":
      return "PASSWORD_RESET";
    case "signIn":
      return "EMAIL_SIGNIN";
    case "verifyEmail":
      return "VERIFY_EMAIL";
    case "verifyAndChangeEmail":
      return "VERIFY_AND_CHANGE_EMAIL";
    case "revertSecondFactorAddition":
      return "REVERT_SECOND_FACTOR_ADDITION";
    default:
      return null;
  }
}
function parseDeepLink(url) {
  var link = querystringDecode(extractQuerystring(url))["link"];
  var doubleDeepLink = link ? querystringDecode(extractQuerystring(link))["deep_link_id"] : null;
  var iOSDeepLink = querystringDecode(extractQuerystring(url))["deep_link_id"];
  var iOSDoubleDeepLink = iOSDeepLink ? querystringDecode(extractQuerystring(iOSDeepLink))["link"] : null;
  return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
var ActionCodeURL = (
  /** @class */
  function() {
    function ActionCodeURL2(actionLink) {
      var _a2, _b, _c, _d, _e, _f;
      var searchParams = querystringDecode(extractQuerystring(actionLink));
      var apiKey = (_a2 = searchParams[
        "apiKey"
        /* QueryField.API_KEY */
      ]) !== null && _a2 !== void 0 ? _a2 : null;
      var code = (_b = searchParams[
        "oobCode"
        /* QueryField.CODE */
      ]) !== null && _b !== void 0 ? _b : null;
      var operation = parseMode((_c = searchParams[
        "mode"
        /* QueryField.MODE */
      ]) !== null && _c !== void 0 ? _c : null);
      _assert(
        apiKey && code && operation,
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      );
      this.apiKey = apiKey;
      this.operation = operation;
      this.code = code;
      this.continueUrl = (_d = searchParams[
        "continueUrl"
        /* QueryField.CONTINUE_URL */
      ]) !== null && _d !== void 0 ? _d : null;
      this.languageCode = (_e = searchParams[
        "languageCode"
        /* QueryField.LANGUAGE_CODE */
      ]) !== null && _e !== void 0 ? _e : null;
      this.tenantId = (_f = searchParams[
        "tenantId"
        /* QueryField.TENANT_ID */
      ]) !== null && _f !== void 0 ? _f : null;
    }
    ActionCodeURL2.parseLink = function(link) {
      var actionLink = parseDeepLink(link);
      try {
        return new ActionCodeURL2(actionLink);
      } catch (_a2) {
        return null;
      }
    };
    return ActionCodeURL2;
  }()
);
function parseActionCodeURL(link) {
  return ActionCodeURL.parseLink(link);
}
var EmailAuthProvider = (
  /** @class */
  function() {
    function EmailAuthProvider2() {
      this.providerId = EmailAuthProvider2.PROVIDER_ID;
    }
    EmailAuthProvider2.credential = function(email, password) {
      return EmailAuthCredential._fromEmailAndPassword(email, password);
    };
    EmailAuthProvider2.credentialWithLink = function(email, emailLink) {
      var actionCodeUrl = ActionCodeURL.parseLink(emailLink);
      _assert(
        actionCodeUrl,
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      );
      return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);
    };
    EmailAuthProvider2.PROVIDER_ID = "password";
    EmailAuthProvider2.EMAIL_PASSWORD_SIGN_IN_METHOD = "password";
    EmailAuthProvider2.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";
    return EmailAuthProvider2;
  }()
);
var FederatedAuthProvider = (
  /** @class */
  function() {
    function FederatedAuthProvider2(providerId) {
      this.providerId = providerId;
      this.defaultLanguageCode = null;
      this.customParameters = {};
    }
    FederatedAuthProvider2.prototype.setDefaultLanguage = function(languageCode) {
      this.defaultLanguageCode = languageCode;
    };
    FederatedAuthProvider2.prototype.setCustomParameters = function(customOAuthParameters) {
      this.customParameters = customOAuthParameters;
      return this;
    };
    FederatedAuthProvider2.prototype.getCustomParameters = function() {
      return this.customParameters;
    };
    return FederatedAuthProvider2;
  }()
);
var BaseOAuthProvider = (
  /** @class */
  function(_super) {
    __extends(BaseOAuthProvider2, _super);
    function BaseOAuthProvider2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.scopes = [];
      return _this;
    }
    BaseOAuthProvider2.prototype.addScope = function(scope) {
      if (!this.scopes.includes(scope)) {
        this.scopes.push(scope);
      }
      return this;
    };
    BaseOAuthProvider2.prototype.getScopes = function() {
      return __spreadArray([], this.scopes, true);
    };
    return BaseOAuthProvider2;
  }(FederatedAuthProvider)
);
var OAuthProvider = (
  /** @class */
  function(_super) {
    __extends(OAuthProvider2, _super);
    function OAuthProvider2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    OAuthProvider2.credentialFromJSON = function(json) {
      var obj = typeof json === "string" ? JSON.parse(json) : json;
      _assert(
        "providerId" in obj && "signInMethod" in obj,
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      );
      return OAuthCredential._fromParams(obj);
    };
    OAuthProvider2.prototype.credential = function(params) {
      return this._credential(__assign(__assign({}, params), { nonce: params.rawNonce }));
    };
    OAuthProvider2.prototype._credential = function(params) {
      _assert(
        params.idToken || params.accessToken,
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      );
      return OAuthCredential._fromParams(__assign(__assign({}, params), { providerId: this.providerId, signInMethod: this.providerId }));
    };
    OAuthProvider2.credentialFromResult = function(userCredential) {
      return OAuthProvider2.oauthCredentialFromTaggedObject(userCredential);
    };
    OAuthProvider2.credentialFromError = function(error) {
      return OAuthProvider2.oauthCredentialFromTaggedObject(error.customData || {});
    };
    OAuthProvider2.oauthCredentialFromTaggedObject = function(_a2) {
      var tokenResponse = _a2._tokenResponse;
      if (!tokenResponse) {
        return null;
      }
      var _b = tokenResponse, oauthIdToken = _b.oauthIdToken, oauthAccessToken = _b.oauthAccessToken, oauthTokenSecret = _b.oauthTokenSecret, pendingToken = _b.pendingToken, nonce = _b.nonce, providerId = _b.providerId;
      if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {
        return null;
      }
      if (!providerId) {
        return null;
      }
      try {
        return new OAuthProvider2(providerId)._credential({
          idToken: oauthIdToken,
          accessToken: oauthAccessToken,
          nonce,
          pendingToken
        });
      } catch (e) {
        return null;
      }
    };
    return OAuthProvider2;
  }(BaseOAuthProvider)
);
var FacebookAuthProvider = (
  /** @class */
  function(_super) {
    __extends(FacebookAuthProvider2, _super);
    function FacebookAuthProvider2() {
      return _super.call(
        this,
        "facebook.com"
        /* ProviderId.FACEBOOK */
      ) || this;
    }
    FacebookAuthProvider2.credential = function(accessToken) {
      return OAuthCredential._fromParams({
        providerId: FacebookAuthProvider2.PROVIDER_ID,
        signInMethod: FacebookAuthProvider2.FACEBOOK_SIGN_IN_METHOD,
        accessToken
      });
    };
    FacebookAuthProvider2.credentialFromResult = function(userCredential) {
      return FacebookAuthProvider2.credentialFromTaggedObject(userCredential);
    };
    FacebookAuthProvider2.credentialFromError = function(error) {
      return FacebookAuthProvider2.credentialFromTaggedObject(error.customData || {});
    };
    FacebookAuthProvider2.credentialFromTaggedObject = function(_a2) {
      var tokenResponse = _a2._tokenResponse;
      if (!tokenResponse || !("oauthAccessToken" in tokenResponse)) {
        return null;
      }
      if (!tokenResponse.oauthAccessToken) {
        return null;
      }
      try {
        return FacebookAuthProvider2.credential(tokenResponse.oauthAccessToken);
      } catch (_b) {
        return null;
      }
    };
    FacebookAuthProvider2.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
    FacebookAuthProvider2.PROVIDER_ID = "facebook.com";
    return FacebookAuthProvider2;
  }(BaseOAuthProvider)
);
var GoogleAuthProvider = (
  /** @class */
  function(_super) {
    __extends(GoogleAuthProvider2, _super);
    function GoogleAuthProvider2() {
      var _this = _super.call(
        this,
        "google.com"
        /* ProviderId.GOOGLE */
      ) || this;
      _this.addScope("profile");
      return _this;
    }
    GoogleAuthProvider2.credential = function(idToken, accessToken) {
      return OAuthCredential._fromParams({
        providerId: GoogleAuthProvider2.PROVIDER_ID,
        signInMethod: GoogleAuthProvider2.GOOGLE_SIGN_IN_METHOD,
        idToken,
        accessToken
      });
    };
    GoogleAuthProvider2.credentialFromResult = function(userCredential) {
      return GoogleAuthProvider2.credentialFromTaggedObject(userCredential);
    };
    GoogleAuthProvider2.credentialFromError = function(error) {
      return GoogleAuthProvider2.credentialFromTaggedObject(error.customData || {});
    };
    GoogleAuthProvider2.credentialFromTaggedObject = function(_a2) {
      var tokenResponse = _a2._tokenResponse;
      if (!tokenResponse) {
        return null;
      }
      var _b = tokenResponse, oauthIdToken = _b.oauthIdToken, oauthAccessToken = _b.oauthAccessToken;
      if (!oauthIdToken && !oauthAccessToken) {
        return null;
      }
      try {
        return GoogleAuthProvider2.credential(oauthIdToken, oauthAccessToken);
      } catch (_c) {
        return null;
      }
    };
    GoogleAuthProvider2.GOOGLE_SIGN_IN_METHOD = "google.com";
    GoogleAuthProvider2.PROVIDER_ID = "google.com";
    return GoogleAuthProvider2;
  }(BaseOAuthProvider)
);
var GithubAuthProvider = (
  /** @class */
  function(_super) {
    __extends(GithubAuthProvider2, _super);
    function GithubAuthProvider2() {
      return _super.call(
        this,
        "github.com"
        /* ProviderId.GITHUB */
      ) || this;
    }
    GithubAuthProvider2.credential = function(accessToken) {
      return OAuthCredential._fromParams({
        providerId: GithubAuthProvider2.PROVIDER_ID,
        signInMethod: GithubAuthProvider2.GITHUB_SIGN_IN_METHOD,
        accessToken
      });
    };
    GithubAuthProvider2.credentialFromResult = function(userCredential) {
      return GithubAuthProvider2.credentialFromTaggedObject(userCredential);
    };
    GithubAuthProvider2.credentialFromError = function(error) {
      return GithubAuthProvider2.credentialFromTaggedObject(error.customData || {});
    };
    GithubAuthProvider2.credentialFromTaggedObject = function(_a2) {
      var tokenResponse = _a2._tokenResponse;
      if (!tokenResponse || !("oauthAccessToken" in tokenResponse)) {
        return null;
      }
      if (!tokenResponse.oauthAccessToken) {
        return null;
      }
      try {
        return GithubAuthProvider2.credential(tokenResponse.oauthAccessToken);
      } catch (_b) {
        return null;
      }
    };
    GithubAuthProvider2.GITHUB_SIGN_IN_METHOD = "github.com";
    GithubAuthProvider2.PROVIDER_ID = "github.com";
    return GithubAuthProvider2;
  }(BaseOAuthProvider)
);
var IDP_REQUEST_URI = "http://localhost";
var SAMLAuthCredential = (
  /** @class */
  function(_super) {
    __extends(SAMLAuthCredential2, _super);
    function SAMLAuthCredential2(providerId, pendingToken) {
      var _this = _super.call(this, providerId, providerId) || this;
      _this.pendingToken = pendingToken;
      return _this;
    }
    SAMLAuthCredential2.prototype._getIdTokenResponse = function(auth) {
      var request = this.buildRequest();
      return signInWithIdp(auth, request);
    };
    SAMLAuthCredential2.prototype._linkToIdToken = function(auth, idToken) {
      var request = this.buildRequest();
      request.idToken = idToken;
      return signInWithIdp(auth, request);
    };
    SAMLAuthCredential2.prototype._getReauthenticationResolver = function(auth) {
      var request = this.buildRequest();
      request.autoCreate = false;
      return signInWithIdp(auth, request);
    };
    SAMLAuthCredential2.prototype.toJSON = function() {
      return {
        signInMethod: this.signInMethod,
        providerId: this.providerId,
        pendingToken: this.pendingToken
      };
    };
    SAMLAuthCredential2.fromJSON = function(json) {
      var obj = typeof json === "string" ? JSON.parse(json) : json;
      var providerId = obj.providerId, signInMethod = obj.signInMethod, pendingToken = obj.pendingToken;
      if (!providerId || !signInMethod || !pendingToken || providerId !== signInMethod) {
        return null;
      }
      return new SAMLAuthCredential2(providerId, pendingToken);
    };
    SAMLAuthCredential2._create = function(providerId, pendingToken) {
      return new SAMLAuthCredential2(providerId, pendingToken);
    };
    SAMLAuthCredential2.prototype.buildRequest = function() {
      return {
        requestUri: IDP_REQUEST_URI,
        returnSecureToken: true,
        pendingToken: this.pendingToken
      };
    };
    return SAMLAuthCredential2;
  }(AuthCredential)
);
var SAML_PROVIDER_PREFIX = "saml.";
var SAMLAuthProvider = (
  /** @class */
  function(_super) {
    __extends(SAMLAuthProvider2, _super);
    function SAMLAuthProvider2(providerId) {
      _assert(
        providerId.startsWith(SAML_PROVIDER_PREFIX),
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      );
      return _super.call(this, providerId) || this;
    }
    SAMLAuthProvider2.credentialFromResult = function(userCredential) {
      return SAMLAuthProvider2.samlCredentialFromTaggedObject(userCredential);
    };
    SAMLAuthProvider2.credentialFromError = function(error) {
      return SAMLAuthProvider2.samlCredentialFromTaggedObject(error.customData || {});
    };
    SAMLAuthProvider2.credentialFromJSON = function(json) {
      var credential = SAMLAuthCredential.fromJSON(json);
      _assert(
        credential,
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      );
      return credential;
    };
    SAMLAuthProvider2.samlCredentialFromTaggedObject = function(_a2) {
      var tokenResponse = _a2._tokenResponse;
      if (!tokenResponse) {
        return null;
      }
      var _b = tokenResponse, pendingToken = _b.pendingToken, providerId = _b.providerId;
      if (!pendingToken || !providerId) {
        return null;
      }
      try {
        return SAMLAuthCredential._create(providerId, pendingToken);
      } catch (e) {
        return null;
      }
    };
    return SAMLAuthProvider2;
  }(FederatedAuthProvider)
);
var TwitterAuthProvider = (
  /** @class */
  function(_super) {
    __extends(TwitterAuthProvider2, _super);
    function TwitterAuthProvider2() {
      return _super.call(
        this,
        "twitter.com"
        /* ProviderId.TWITTER */
      ) || this;
    }
    TwitterAuthProvider2.credential = function(token, secret) {
      return OAuthCredential._fromParams({
        providerId: TwitterAuthProvider2.PROVIDER_ID,
        signInMethod: TwitterAuthProvider2.TWITTER_SIGN_IN_METHOD,
        oauthToken: token,
        oauthTokenSecret: secret
      });
    };
    TwitterAuthProvider2.credentialFromResult = function(userCredential) {
      return TwitterAuthProvider2.credentialFromTaggedObject(userCredential);
    };
    TwitterAuthProvider2.credentialFromError = function(error) {
      return TwitterAuthProvider2.credentialFromTaggedObject(error.customData || {});
    };
    TwitterAuthProvider2.credentialFromTaggedObject = function(_a2) {
      var tokenResponse = _a2._tokenResponse;
      if (!tokenResponse) {
        return null;
      }
      var _b = tokenResponse, oauthAccessToken = _b.oauthAccessToken, oauthTokenSecret = _b.oauthTokenSecret;
      if (!oauthAccessToken || !oauthTokenSecret) {
        return null;
      }
      try {
        return TwitterAuthProvider2.credential(oauthAccessToken, oauthTokenSecret);
      } catch (_c) {
        return null;
      }
    };
    TwitterAuthProvider2.TWITTER_SIGN_IN_METHOD = "twitter.com";
    TwitterAuthProvider2.PROVIDER_ID = "twitter.com";
    return TwitterAuthProvider2;
  }(BaseOAuthProvider)
);
function signUp(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performSignInRequest(auth, "POST", "/v1/accounts:signUp", _addTidIfNecessary(auth, request))];
    });
  });
}
var UserCredentialImpl = (
  /** @class */
  function() {
    function UserCredentialImpl2(params) {
      this.user = params.user;
      this.providerId = params.providerId;
      this._tokenResponse = params._tokenResponse;
      this.operationType = params.operationType;
    }
    UserCredentialImpl2._fromIdTokenResponse = function(auth, operationType, idTokenResponse, isAnonymous) {
      if (isAnonymous === void 0) {
        isAnonymous = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        var user, providerId, userCred;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous)];
            case 1:
              user = _a2.sent();
              providerId = providerIdForResponse(idTokenResponse);
              userCred = new UserCredentialImpl2({
                user,
                providerId,
                _tokenResponse: idTokenResponse,
                operationType
              });
              return [2, userCred];
          }
        });
      });
    };
    UserCredentialImpl2._forOperation = function(user, operationType, response) {
      return __awaiter(this, void 0, void 0, function() {
        var providerId;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, user._updateTokensIfNecessary(
                response,
                /* reload */
                true
              )];
            case 1:
              _a2.sent();
              providerId = providerIdForResponse(response);
              return [2, new UserCredentialImpl2({
                user,
                providerId,
                _tokenResponse: response,
                operationType
              })];
          }
        });
      });
    };
    return UserCredentialImpl2;
  }()
);
function providerIdForResponse(response) {
  if (response.providerId) {
    return response.providerId;
  }
  if ("phoneNumber" in response) {
    return "phone";
  }
  return null;
}
function signInAnonymously(auth) {
  var _a2;
  return __awaiter(this, void 0, void 0, function() {
    var authInternal, response, userCredential;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          authInternal = _castAuth(auth);
          return [4, authInternal._initializationPromise];
        case 1:
          _b.sent();
          if ((_a2 = authInternal.currentUser) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous) {
            return [2, new UserCredentialImpl({
              user: authInternal.currentUser,
              providerId: null,
              operationType: "signIn"
              /* OperationType.SIGN_IN */
            })];
          }
          return [4, signUp(authInternal, {
            returnSecureToken: true
          })];
        case 2:
          response = _b.sent();
          return [4, UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn", response, true)];
        case 3:
          userCredential = _b.sent();
          return [4, authInternal._updateCurrentUser(userCredential.user)];
        case 4:
          _b.sent();
          return [2, userCredential];
      }
    });
  });
}
var MultiFactorError = (
  /** @class */
  function(_super) {
    __extends(MultiFactorError2, _super);
    function MultiFactorError2(auth, error, operationType, user) {
      var _this = this;
      var _a2;
      _this = _super.call(this, error.code, error.message) || this;
      _this.operationType = operationType;
      _this.user = user;
      Object.setPrototypeOf(_this, MultiFactorError2.prototype);
      _this.customData = {
        appName: auth.name,
        tenantId: (_a2 = auth.tenantId) !== null && _a2 !== void 0 ? _a2 : void 0,
        _serverResponse: error.customData._serverResponse,
        operationType
      };
      return _this;
    }
    MultiFactorError2._fromErrorAndOperation = function(auth, error, operationType, user) {
      return new MultiFactorError2(auth, error, operationType, user);
    };
    return MultiFactorError2;
  }(FirebaseError)
);
function _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {
  var idTokenProvider = operationType === "reauthenticate" ? credential._getReauthenticationResolver(auth) : credential._getIdTokenResponse(auth);
  return idTokenProvider.catch(function(error) {
    if (error.code === "auth/".concat(
      "multi-factor-auth-required"
      /* AuthErrorCode.MFA_REQUIRED */
    )) {
      throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);
    }
    throw error;
  });
}
function providerDataAsNames(providerData) {
  return new Set(providerData.map(function(_a2) {
    var providerId = _a2.providerId;
    return providerId;
  }).filter(function(pid) {
    return !!pid;
  }));
}
function unlink(user, providerId) {
  return __awaiter(this, void 0, void 0, function() {
    var userInternal, providerUserInfo, _a2, _b, providersLeft;
    var _c;
    return __generator(this, function(_d) {
      switch (_d.label) {
        case 0:
          userInternal = getModularInstance(user);
          return [4, _assertLinkedStatus(true, userInternal, providerId)];
        case 1:
          _d.sent();
          _a2 = deleteLinkedAccounts;
          _b = [userInternal.auth];
          _c = {};
          return [4, userInternal.getIdToken()];
        case 2:
          return [4, _a2.apply(void 0, _b.concat([(_c.idToken = _d.sent(), _c.deleteProvider = [providerId], _c)]))];
        case 3:
          providerUserInfo = _d.sent().providerUserInfo;
          providersLeft = providerDataAsNames(providerUserInfo || []);
          userInternal.providerData = userInternal.providerData.filter(function(pd) {
            return providersLeft.has(pd.providerId);
          });
          if (!providersLeft.has(
            "phone"
            /* ProviderId.PHONE */
          )) {
            userInternal.phoneNumber = null;
          }
          return [4, userInternal.auth._persistUserIfCurrent(userInternal)];
        case 4:
          _d.sent();
          return [2, userInternal];
      }
    });
  });
}
function _link$1(user, credential, bypassAuthState) {
  if (bypassAuthState === void 0) {
    bypassAuthState = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var response, _a2, _b, _c, _d, _e;
    return __generator(this, function(_f) {
      switch (_f.label) {
        case 0:
          _a2 = _logoutIfInvalidated;
          _b = [user];
          _d = (_c = credential)._linkToIdToken;
          _e = [user.auth];
          return [4, user.getIdToken()];
        case 1:
          return [4, _a2.apply(void 0, _b.concat([
            _d.apply(_c, _e.concat([_f.sent()])),
            bypassAuthState
          ]))];
        case 2:
          response = _f.sent();
          return [2, UserCredentialImpl._forOperation(user, "link", response)];
      }
    });
  });
}
function _assertLinkedStatus(expected, user, provider) {
  return __awaiter(this, void 0, void 0, function() {
    var providerIds, code;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, _reloadWithoutSaving(user)];
        case 1:
          _a2.sent();
          providerIds = providerDataAsNames(user.providerData);
          code = expected === false ? "provider-already-linked" : "no-such-provider";
          _assert(providerIds.has(provider) === expected, user.auth, code);
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function _reauthenticate(user, credential, bypassAuthState) {
  if (bypassAuthState === void 0) {
    bypassAuthState = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var auth, operationType, response, parsed, localId, e_1;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          auth = user.auth;
          operationType = "reauthenticate";
          _a2.label = 1;
        case 1:
          _a2.trys.push([1, 3, , 4]);
          return [4, _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState)];
        case 2:
          response = _a2.sent();
          _assert(
            response.idToken,
            auth,
            "internal-error"
            /* AuthErrorCode.INTERNAL_ERROR */
          );
          parsed = _parseToken(response.idToken);
          _assert(
            parsed,
            auth,
            "internal-error"
            /* AuthErrorCode.INTERNAL_ERROR */
          );
          localId = parsed.sub;
          _assert(
            user.uid === localId,
            auth,
            "user-mismatch"
            /* AuthErrorCode.USER_MISMATCH */
          );
          return [2, UserCredentialImpl._forOperation(user, operationType, response)];
        case 3:
          e_1 = _a2.sent();
          if ((e_1 === null || e_1 === void 0 ? void 0 : e_1.code) === "auth/".concat(
            "user-not-found"
            /* AuthErrorCode.USER_DELETED */
          )) {
            _fail(
              auth,
              "user-mismatch"
              /* AuthErrorCode.USER_MISMATCH */
            );
          }
          throw e_1;
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function _signInWithCredential(auth, credential, bypassAuthState) {
  if (bypassAuthState === void 0) {
    bypassAuthState = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var operationType, response, userCredential;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          operationType = "signIn";
          return [4, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential)];
        case 1:
          response = _a2.sent();
          return [4, UserCredentialImpl._fromIdTokenResponse(auth, operationType, response)];
        case 2:
          userCredential = _a2.sent();
          if (!!bypassAuthState)
            return [3, 4];
          return [4, auth._updateCurrentUser(userCredential.user)];
        case 3:
          _a2.sent();
          _a2.label = 4;
        case 4:
          return [2, userCredential];
      }
    });
  });
}
function signInWithCredential(auth, credential) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _signInWithCredential(_castAuth(auth), credential)];
    });
  });
}
function linkWithCredential(user, credential) {
  return __awaiter(this, void 0, void 0, function() {
    var userInternal;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          userInternal = getModularInstance(user);
          return [4, _assertLinkedStatus(false, userInternal, credential.providerId)];
        case 1:
          _a2.sent();
          return [2, _link$1(userInternal, credential)];
      }
    });
  });
}
function reauthenticateWithCredential(user, credential) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _reauthenticate(getModularInstance(user), credential)];
    });
  });
}
function signInWithCustomToken$1(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performSignInRequest(auth, "POST", "/v1/accounts:signInWithCustomToken", _addTidIfNecessary(auth, request))];
    });
  });
}
function signInWithCustomToken(auth, customToken) {
  return __awaiter(this, void 0, void 0, function() {
    var authInternal, response, cred;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          authInternal = _castAuth(auth);
          return [4, signInWithCustomToken$1(authInternal, {
            token: customToken,
            returnSecureToken: true
          })];
        case 1:
          response = _a2.sent();
          return [4, UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn", response)];
        case 2:
          cred = _a2.sent();
          return [4, authInternal._updateCurrentUser(cred.user)];
        case 3:
          _a2.sent();
          return [2, cred];
      }
    });
  });
}
var MultiFactorInfoImpl = (
  /** @class */
  function() {
    function MultiFactorInfoImpl2(factorId, response) {
      this.factorId = factorId;
      this.uid = response.mfaEnrollmentId;
      this.enrollmentTime = new Date(response.enrolledAt).toUTCString();
      this.displayName = response.displayName;
    }
    MultiFactorInfoImpl2._fromServerResponse = function(auth, enrollment) {
      if ("phoneInfo" in enrollment) {
        return PhoneMultiFactorInfoImpl._fromServerResponse(auth, enrollment);
      } else if ("totpInfo" in enrollment) {
        return TotpMultiFactorInfoImpl._fromServerResponse(auth, enrollment);
      }
      return _fail(
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
    };
    return MultiFactorInfoImpl2;
  }()
);
var PhoneMultiFactorInfoImpl = (
  /** @class */
  function(_super) {
    __extends(PhoneMultiFactorInfoImpl2, _super);
    function PhoneMultiFactorInfoImpl2(response) {
      var _this = _super.call(this, "phone", response) || this;
      _this.phoneNumber = response.phoneInfo;
      return _this;
    }
    PhoneMultiFactorInfoImpl2._fromServerResponse = function(_auth, enrollment) {
      return new PhoneMultiFactorInfoImpl2(enrollment);
    };
    return PhoneMultiFactorInfoImpl2;
  }(MultiFactorInfoImpl)
);
var TotpMultiFactorInfoImpl = (
  /** @class */
  function(_super) {
    __extends(TotpMultiFactorInfoImpl2, _super);
    function TotpMultiFactorInfoImpl2(response) {
      return _super.call(this, "totp", response) || this;
    }
    TotpMultiFactorInfoImpl2._fromServerResponse = function(_auth, enrollment) {
      return new TotpMultiFactorInfoImpl2(enrollment);
    };
    return TotpMultiFactorInfoImpl2;
  }(MultiFactorInfoImpl)
);
function _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {
  var _a2;
  _assert(
    ((_a2 = actionCodeSettings.url) === null || _a2 === void 0 ? void 0 : _a2.length) > 0,
    auth,
    "invalid-continue-uri"
    /* AuthErrorCode.INVALID_CONTINUE_URI */
  );
  _assert(
    typeof actionCodeSettings.dynamicLinkDomain === "undefined" || actionCodeSettings.dynamicLinkDomain.length > 0,
    auth,
    "invalid-dynamic-link-domain"
    /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */
  );
  request.continueUrl = actionCodeSettings.url;
  request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;
  request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;
  if (actionCodeSettings.iOS) {
    _assert(
      actionCodeSettings.iOS.bundleId.length > 0,
      auth,
      "missing-ios-bundle-id"
      /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */
    );
    request.iOSBundleId = actionCodeSettings.iOS.bundleId;
  }
  if (actionCodeSettings.android) {
    _assert(
      actionCodeSettings.android.packageName.length > 0,
      auth,
      "missing-android-pkg-name"
      /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */
    );
    request.androidInstallApp = actionCodeSettings.android.installApp;
    request.androidMinimumVersionCode = actionCodeSettings.android.minimumVersion;
    request.androidPackageName = actionCodeSettings.android.packageName;
  }
}
function recachePasswordPolicy(auth) {
  return __awaiter(this, void 0, void 0, function() {
    var authInternal;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          authInternal = _castAuth(auth);
          if (!authInternal._getPasswordPolicyInternal())
            return [3, 2];
          return [4, authInternal._updatePasswordPolicy()];
        case 1:
          _a2.sent();
          _a2.label = 2;
        case 2:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function sendPasswordResetEmail(auth, email, actionCodeSettings) {
  return __awaiter(this, void 0, void 0, function() {
    var authInternal, request;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          authInternal = _castAuth(auth);
          request = {
            requestType: "PASSWORD_RESET",
            email,
            clientType: "CLIENT_TYPE_WEB"
            /* RecaptchaClientType.WEB */
          };
          if (actionCodeSettings) {
            _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);
          }
          return [4, handleRecaptchaFlow(authInternal, request, "getOobCode", sendPasswordResetEmail$1)];
        case 1:
          _a2.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function confirmPasswordReset(auth, oobCode, newPassword) {
  return __awaiter(this, void 0, void 0, function() {
    var _this = this;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, resetPassword(getModularInstance(auth), {
            oobCode,
            newPassword
          }).catch(function(error) {
            return __awaiter(_this, void 0, void 0, function() {
              return __generator(this, function(_a3) {
                if (error.code === "auth/".concat(
                  "password-does-not-meet-requirements"
                  /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */
                )) {
                  void recachePasswordPolicy(auth);
                }
                throw error;
              });
            });
          })];
        case 1:
          _a2.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function applyActionCode(auth, oobCode) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, applyActionCode$1(getModularInstance(auth), { oobCode })];
        case 1:
          _a2.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function checkActionCode(auth, oobCode) {
  return __awaiter(this, void 0, void 0, function() {
    var authModular, response, operation, multiFactorInfo;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          authModular = getModularInstance(auth);
          return [4, resetPassword(authModular, { oobCode })];
        case 1:
          response = _a2.sent();
          operation = response.requestType;
          _assert(
            operation,
            authModular,
            "internal-error"
            /* AuthErrorCode.INTERNAL_ERROR */
          );
          switch (operation) {
            case "EMAIL_SIGNIN":
              break;
            case "VERIFY_AND_CHANGE_EMAIL":
              _assert(
                response.newEmail,
                authModular,
                "internal-error"
                /* AuthErrorCode.INTERNAL_ERROR */
              );
              break;
            case "REVERT_SECOND_FACTOR_ADDITION":
              _assert(
                response.mfaInfo,
                authModular,
                "internal-error"
                /* AuthErrorCode.INTERNAL_ERROR */
              );
            default:
              _assert(
                response.email,
                authModular,
                "internal-error"
                /* AuthErrorCode.INTERNAL_ERROR */
              );
          }
          multiFactorInfo = null;
          if (response.mfaInfo) {
            multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);
          }
          return [2, {
            data: {
              email: (response.requestType === "VERIFY_AND_CHANGE_EMAIL" ? response.newEmail : response.email) || null,
              previousEmail: (response.requestType === "VERIFY_AND_CHANGE_EMAIL" ? response.email : response.newEmail) || null,
              multiFactorInfo
            },
            operation
          }];
      }
    });
  });
}
function verifyPasswordResetCode(auth, code) {
  return __awaiter(this, void 0, void 0, function() {
    var data;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, checkActionCode(getModularInstance(auth), code)];
        case 1:
          data = _a2.sent().data;
          return [2, data.email];
      }
    });
  });
}
function createUserWithEmailAndPassword(auth, email, password) {
  return __awaiter(this, void 0, void 0, function() {
    var authInternal, request, signUpResponse, response, userCredential;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          authInternal = _castAuth(auth);
          request = {
            returnSecureToken: true,
            email,
            password,
            clientType: "CLIENT_TYPE_WEB"
            /* RecaptchaClientType.WEB */
          };
          signUpResponse = handleRecaptchaFlow(authInternal, request, "signUpPassword", signUp);
          return [4, signUpResponse.catch(function(error) {
            if (error.code === "auth/".concat(
              "password-does-not-meet-requirements"
              /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */
            )) {
              void recachePasswordPolicy(auth);
            }
            throw error;
          })];
        case 1:
          response = _a2.sent();
          return [4, UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn", response)];
        case 2:
          userCredential = _a2.sent();
          return [4, authInternal._updateCurrentUser(userCredential.user)];
        case 3:
          _a2.sent();
          return [2, userCredential];
      }
    });
  });
}
function signInWithEmailAndPassword(auth, email, password) {
  var _this = this;
  return signInWithCredential(getModularInstance(auth), EmailAuthProvider.credential(email, password)).catch(function(error) {
    return __awaiter(_this, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        if (error.code === "auth/".concat(
          "password-does-not-meet-requirements"
          /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */
        )) {
          void recachePasswordPolicy(auth);
        }
        throw error;
      });
    });
  });
}
function sendSignInLinkToEmail(auth, email, actionCodeSettings) {
  return __awaiter(this, void 0, void 0, function() {
    function setActionCodeSettings(request2, actionCodeSettings2) {
      _assert(
        actionCodeSettings2.handleCodeInApp,
        authInternal,
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      );
      if (actionCodeSettings2) {
        _setActionCodeSettingsOnRequest(authInternal, request2, actionCodeSettings2);
      }
    }
    var authInternal, request;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          authInternal = _castAuth(auth);
          request = {
            requestType: "EMAIL_SIGNIN",
            email,
            clientType: "CLIENT_TYPE_WEB"
            /* RecaptchaClientType.WEB */
          };
          setActionCodeSettings(request, actionCodeSettings);
          return [4, handleRecaptchaFlow(authInternal, request, "getOobCode", sendSignInLinkToEmail$1)];
        case 1:
          _a2.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function isSignInWithEmailLink(auth, emailLink) {
  var actionCodeUrl = ActionCodeURL.parseLink(emailLink);
  return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === "EMAIL_SIGNIN";
}
function signInWithEmailLink(auth, email, emailLink) {
  return __awaiter(this, void 0, void 0, function() {
    var authModular, credential;
    return __generator(this, function(_a2) {
      authModular = getModularInstance(auth);
      credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());
      _assert(
        credential._tenantId === (authModular.tenantId || null),
        authModular,
        "tenant-id-mismatch"
        /* AuthErrorCode.TENANT_ID_MISMATCH */
      );
      return [2, signInWithCredential(authModular, credential)];
    });
  });
}
function createAuthUri(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "POST", "/v1/accounts:createAuthUri", _addTidIfNecessary(auth, request))];
    });
  });
}
function fetchSignInMethodsForEmail(auth, email) {
  return __awaiter(this, void 0, void 0, function() {
    var continueUri, request, signinMethods;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          continueUri = _isHttpOrHttps() ? _getCurrentUrl() : "http://localhost";
          request = {
            identifier: email,
            continueUri
          };
          return [4, createAuthUri(getModularInstance(auth), request)];
        case 1:
          signinMethods = _a2.sent().signinMethods;
          return [2, signinMethods || []];
      }
    });
  });
}
function sendEmailVerification(user, actionCodeSettings) {
  return __awaiter(this, void 0, void 0, function() {
    var userInternal, idToken, request, email;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          userInternal = getModularInstance(user);
          return [4, user.getIdToken()];
        case 1:
          idToken = _a2.sent();
          request = {
            requestType: "VERIFY_EMAIL",
            idToken
          };
          if (actionCodeSettings) {
            _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);
          }
          return [4, sendEmailVerification$1(userInternal.auth, request)];
        case 2:
          email = _a2.sent().email;
          if (!(email !== user.email))
            return [3, 4];
          return [4, user.reload()];
        case 3:
          _a2.sent();
          _a2.label = 4;
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function verifyBeforeUpdateEmail(user, newEmail, actionCodeSettings) {
  return __awaiter(this, void 0, void 0, function() {
    var userInternal, idToken, request, email;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          userInternal = getModularInstance(user);
          return [4, user.getIdToken()];
        case 1:
          idToken = _a2.sent();
          request = {
            requestType: "VERIFY_AND_CHANGE_EMAIL",
            idToken,
            newEmail
          };
          if (actionCodeSettings) {
            _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);
          }
          return [4, verifyAndChangeEmail(userInternal.auth, request)];
        case 2:
          email = _a2.sent().email;
          if (!(email !== user.email))
            return [3, 4];
          return [4, user.reload()];
        case 3:
          _a2.sent();
          _a2.label = 4;
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function updateProfile$1(auth, request) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "POST", "/v1/accounts:update", request)];
    });
  });
}
function updateProfile(user, _a2) {
  var displayName = _a2.displayName, photoUrl = _a2.photoURL;
  return __awaiter(this, void 0, void 0, function() {
    var userInternal, idToken, profileRequest, response, passwordProvider;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          if (displayName === void 0 && photoUrl === void 0) {
            return [
              2
              /*return*/
            ];
          }
          userInternal = getModularInstance(user);
          return [4, userInternal.getIdToken()];
        case 1:
          idToken = _b.sent();
          profileRequest = {
            idToken,
            displayName,
            photoUrl,
            returnSecureToken: true
          };
          return [4, _logoutIfInvalidated(userInternal, updateProfile$1(userInternal.auth, profileRequest))];
        case 2:
          response = _b.sent();
          userInternal.displayName = response.displayName || null;
          userInternal.photoURL = response.photoUrl || null;
          passwordProvider = userInternal.providerData.find(function(_a3) {
            var providerId = _a3.providerId;
            return providerId === "password";
          });
          if (passwordProvider) {
            passwordProvider.displayName = userInternal.displayName;
            passwordProvider.photoURL = userInternal.photoURL;
          }
          return [4, userInternal._updateTokensIfNecessary(response)];
        case 3:
          _b.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function updateEmail(user, newEmail) {
  return updateEmailOrPassword(getModularInstance(user), newEmail, null);
}
function updatePassword(user, newPassword) {
  return updateEmailOrPassword(getModularInstance(user), null, newPassword);
}
function updateEmailOrPassword(user, email, password) {
  return __awaiter(this, void 0, void 0, function() {
    var auth, idToken, request, response;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          auth = user.auth;
          return [4, user.getIdToken()];
        case 1:
          idToken = _a2.sent();
          request = {
            idToken,
            returnSecureToken: true
          };
          if (email) {
            request.email = email;
          }
          if (password) {
            request.password = password;
          }
          return [4, _logoutIfInvalidated(user, updateEmailPassword(auth, request))];
        case 2:
          response = _a2.sent();
          return [4, user._updateTokensIfNecessary(
            response,
            /* reload */
            true
          )];
        case 3:
          _a2.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function _fromIdTokenResponse(idTokenResponse) {
  var _a2, _b;
  if (!idTokenResponse) {
    return null;
  }
  var providerId = idTokenResponse.providerId;
  var profile = idTokenResponse.rawUserInfo ? JSON.parse(idTokenResponse.rawUserInfo) : {};
  var isNewUser = idTokenResponse.isNewUser || idTokenResponse.kind === "identitytoolkit#SignupNewUserResponse";
  if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {
    var signInProvider = (_b = (_a2 = _parseToken(idTokenResponse.idToken)) === null || _a2 === void 0 ? void 0 : _a2.firebase) === null || _b === void 0 ? void 0 : _b["sign_in_provider"];
    if (signInProvider) {
      var filteredProviderId = signInProvider !== "anonymous" && signInProvider !== "custom" ? signInProvider : null;
      return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);
    }
  }
  if (!providerId) {
    return null;
  }
  switch (providerId) {
    case "facebook.com":
      return new FacebookAdditionalUserInfo(isNewUser, profile);
    case "github.com":
      return new GithubAdditionalUserInfo(isNewUser, profile);
    case "google.com":
      return new GoogleAdditionalUserInfo(isNewUser, profile);
    case "twitter.com":
      return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);
    case "custom":
    case "anonymous":
      return new GenericAdditionalUserInfo(isNewUser, null);
    default:
      return new GenericAdditionalUserInfo(isNewUser, providerId, profile);
  }
}
var GenericAdditionalUserInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function GenericAdditionalUserInfo2(isNewUser, providerId, profile) {
      if (profile === void 0) {
        profile = {};
      }
      this.isNewUser = isNewUser;
      this.providerId = providerId;
      this.profile = profile;
    }
    return GenericAdditionalUserInfo2;
  }()
);
var FederatedAdditionalUserInfoWithUsername = (
  /** @class */
  function(_super) {
    __extends(FederatedAdditionalUserInfoWithUsername2, _super);
    function FederatedAdditionalUserInfoWithUsername2(isNewUser, providerId, profile, username) {
      var _this = _super.call(this, isNewUser, providerId, profile) || this;
      _this.username = username;
      return _this;
    }
    return FederatedAdditionalUserInfoWithUsername2;
  }(GenericAdditionalUserInfo)
);
var FacebookAdditionalUserInfo = (
  /** @class */
  function(_super) {
    __extends(FacebookAdditionalUserInfo2, _super);
    function FacebookAdditionalUserInfo2(isNewUser, profile) {
      return _super.call(this, isNewUser, "facebook.com", profile) || this;
    }
    return FacebookAdditionalUserInfo2;
  }(GenericAdditionalUserInfo)
);
var GithubAdditionalUserInfo = (
  /** @class */
  function(_super) {
    __extends(GithubAdditionalUserInfo2, _super);
    function GithubAdditionalUserInfo2(isNewUser, profile) {
      return _super.call(this, isNewUser, "github.com", profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === "string" ? profile === null || profile === void 0 ? void 0 : profile.login : null) || this;
    }
    return GithubAdditionalUserInfo2;
  }(FederatedAdditionalUserInfoWithUsername)
);
var GoogleAdditionalUserInfo = (
  /** @class */
  function(_super) {
    __extends(GoogleAdditionalUserInfo2, _super);
    function GoogleAdditionalUserInfo2(isNewUser, profile) {
      return _super.call(this, isNewUser, "google.com", profile) || this;
    }
    return GoogleAdditionalUserInfo2;
  }(GenericAdditionalUserInfo)
);
var TwitterAdditionalUserInfo = (
  /** @class */
  function(_super) {
    __extends(TwitterAdditionalUserInfo2, _super);
    function TwitterAdditionalUserInfo2(isNewUser, profile, screenName) {
      return _super.call(this, isNewUser, "twitter.com", profile, screenName) || this;
    }
    return TwitterAdditionalUserInfo2;
  }(FederatedAdditionalUserInfoWithUsername)
);
function getAdditionalUserInfo(userCredential) {
  var _a2 = userCredential, user = _a2.user, _tokenResponse = _a2._tokenResponse;
  if (user.isAnonymous && !_tokenResponse) {
    return {
      providerId: null,
      isNewUser: false,
      profile: null
    };
  }
  return _fromIdTokenResponse(_tokenResponse);
}
function setPersistence(auth, persistence) {
  return getModularInstance(auth).setPersistence(persistence);
}
function initializeRecaptchaConfig(auth) {
  return _initializeRecaptchaConfig(auth);
}
function validatePassword(auth, password) {
  return __awaiter(this, void 0, void 0, function() {
    var authInternal;
    return __generator(this, function(_a2) {
      authInternal = _castAuth(auth);
      return [2, authInternal.validatePassword(password)];
    });
  });
}
function onIdTokenChanged(auth, nextOrObserver, error, completed) {
  return getModularInstance(auth).onIdTokenChanged(nextOrObserver, error, completed);
}
function beforeAuthStateChanged(auth, callback, onAbort) {
  return getModularInstance(auth).beforeAuthStateChanged(callback, onAbort);
}
function onAuthStateChanged(auth, nextOrObserver, error, completed) {
  return getModularInstance(auth).onAuthStateChanged(nextOrObserver, error, completed);
}
function useDeviceLanguage(auth) {
  getModularInstance(auth).useDeviceLanguage();
}
function updateCurrentUser(auth, user) {
  return getModularInstance(auth).updateCurrentUser(user);
}
function signOut(auth) {
  return getModularInstance(auth).signOut();
}
function revokeAccessToken(auth, token) {
  var authInternal = _castAuth(auth);
  return authInternal.revokeAccessToken(token);
}
function deleteUser(user) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, getModularInstance(user).delete()];
    });
  });
}
var MultiFactorSessionImpl = (
  /** @class */
  function() {
    function MultiFactorSessionImpl2(type, credential, user) {
      this.type = type;
      this.credential = credential;
      this.user = user;
    }
    MultiFactorSessionImpl2._fromIdtoken = function(idToken, user) {
      return new MultiFactorSessionImpl2("enroll", idToken, user);
    };
    MultiFactorSessionImpl2._fromMfaPendingCredential = function(mfaPendingCredential) {
      return new MultiFactorSessionImpl2("signin", mfaPendingCredential);
    };
    MultiFactorSessionImpl2.prototype.toJSON = function() {
      var _a2;
      var key = this.type === "enroll" ? "idToken" : "pendingCredential";
      return {
        multiFactorSession: (_a2 = {}, _a2[key] = this.credential, _a2)
      };
    };
    MultiFactorSessionImpl2.fromJSON = function(obj) {
      var _a2, _b;
      if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {
        if ((_a2 = obj.multiFactorSession) === null || _a2 === void 0 ? void 0 : _a2.pendingCredential) {
          return MultiFactorSessionImpl2._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);
        } else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {
          return MultiFactorSessionImpl2._fromIdtoken(obj.multiFactorSession.idToken);
        }
      }
      return null;
    };
    return MultiFactorSessionImpl2;
  }()
);
var MultiFactorResolverImpl = (
  /** @class */
  function() {
    function MultiFactorResolverImpl2(session, hints, signInResolver) {
      this.session = session;
      this.hints = hints;
      this.signInResolver = signInResolver;
    }
    MultiFactorResolverImpl2._fromError = function(authExtern, error) {
      var _this = this;
      var auth = _castAuth(authExtern);
      var serverResponse = error.customData._serverResponse;
      var hints = (serverResponse.mfaInfo || []).map(function(enrollment) {
        return MultiFactorInfoImpl._fromServerResponse(auth, enrollment);
      });
      _assert(
        serverResponse.mfaPendingCredential,
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      var session = MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);
      return new MultiFactorResolverImpl2(session, hints, function(assertion) {
        return __awaiter(_this, void 0, void 0, function() {
          var mfaResponse, idTokenResponse, _a2, userCredential;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, assertion._process(auth, session)];
              case 1:
                mfaResponse = _b.sent();
                delete serverResponse.mfaInfo;
                delete serverResponse.mfaPendingCredential;
                idTokenResponse = __assign(__assign({}, serverResponse), { idToken: mfaResponse.idToken, refreshToken: mfaResponse.refreshToken });
                _a2 = error.operationType;
                switch (_a2) {
                  case "signIn":
                    return [3, 2];
                  case "reauthenticate":
                    return [3, 5];
                }
                return [3, 6];
              case 2:
                return [4, UserCredentialImpl._fromIdTokenResponse(auth, error.operationType, idTokenResponse)];
              case 3:
                userCredential = _b.sent();
                return [4, auth._updateCurrentUser(userCredential.user)];
              case 4:
                _b.sent();
                return [2, userCredential];
              case 5:
                _assert(
                  error.user,
                  auth,
                  "internal-error"
                  /* AuthErrorCode.INTERNAL_ERROR */
                );
                return [2, UserCredentialImpl._forOperation(error.user, error.operationType, idTokenResponse)];
              case 6:
                _fail(
                  auth,
                  "internal-error"
                  /* AuthErrorCode.INTERNAL_ERROR */
                );
                _b.label = 7;
              case 7:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    };
    MultiFactorResolverImpl2.prototype.resolveSignIn = function(assertionExtern) {
      return __awaiter(this, void 0, void 0, function() {
        var assertion;
        return __generator(this, function(_a2) {
          assertion = assertionExtern;
          return [2, this.signInResolver(assertion)];
        });
      });
    };
    return MultiFactorResolverImpl2;
  }()
);
function getMultiFactorResolver(auth, error) {
  var _a2;
  var authModular = getModularInstance(auth);
  var errorInternal = error;
  _assert(
    error.customData.operationType,
    authModular,
    "argument-error"
    /* AuthErrorCode.ARGUMENT_ERROR */
  );
  _assert(
    (_a2 = errorInternal.customData._serverResponse) === null || _a2 === void 0 ? void 0 : _a2.mfaPendingCredential,
    authModular,
    "argument-error"
    /* AuthErrorCode.ARGUMENT_ERROR */
  );
  return MultiFactorResolverImpl._fromError(authModular, errorInternal);
}
function withdrawMfa(auth, request) {
  return _performApiRequest(auth, "POST", "/v2/accounts/mfaEnrollment:withdraw", _addTidIfNecessary(auth, request));
}
var MultiFactorUserImpl = (
  /** @class */
  function() {
    function MultiFactorUserImpl2(user) {
      var _this = this;
      this.user = user;
      this.enrolledFactors = [];
      user._onReload(function(userInfo) {
        if (userInfo.mfaInfo) {
          _this.enrolledFactors = userInfo.mfaInfo.map(function(enrollment) {
            return MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment);
          });
        }
      });
    }
    MultiFactorUserImpl2._fromUser = function(user) {
      return new MultiFactorUserImpl2(user);
    };
    MultiFactorUserImpl2.prototype.getSession = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, _b;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _b = (_a2 = MultiFactorSessionImpl)._fromIdtoken;
              return [4, this.user.getIdToken()];
            case 1:
              return [2, _b.apply(_a2, [_c.sent(), this.user])];
          }
        });
      });
    };
    MultiFactorUserImpl2.prototype.enroll = function(assertionExtern, displayName) {
      return __awaiter(this, void 0, void 0, function() {
        var assertion, session, finalizeMfaResponse;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              assertion = assertionExtern;
              return [4, this.getSession()];
            case 1:
              session = _a2.sent();
              return [4, _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session, displayName))];
            case 2:
              finalizeMfaResponse = _a2.sent();
              return [4, this.user._updateTokensIfNecessary(finalizeMfaResponse)];
            case 3:
              _a2.sent();
              return [2, this.user.reload()];
          }
        });
      });
    };
    MultiFactorUserImpl2.prototype.unenroll = function(infoOrUid) {
      return __awaiter(this, void 0, void 0, function() {
        var mfaEnrollmentId, idToken, idTokenResponse, e_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              mfaEnrollmentId = typeof infoOrUid === "string" ? infoOrUid : infoOrUid.uid;
              return [4, this.user.getIdToken()];
            case 1:
              idToken = _a2.sent();
              _a2.label = 2;
            case 2:
              _a2.trys.push([2, 6, , 7]);
              return [4, _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {
                idToken,
                mfaEnrollmentId
              }))];
            case 3:
              idTokenResponse = _a2.sent();
              this.enrolledFactors = this.enrolledFactors.filter(function(_a3) {
                var uid = _a3.uid;
                return uid !== mfaEnrollmentId;
              });
              return [4, this.user._updateTokensIfNecessary(idTokenResponse)];
            case 4:
              _a2.sent();
              return [4, this.user.reload()];
            case 5:
              _a2.sent();
              return [3, 7];
            case 6:
              e_1 = _a2.sent();
              throw e_1;
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    return MultiFactorUserImpl2;
  }()
);
var multiFactorUserCache = /* @__PURE__ */ new WeakMap();
function multiFactor(user) {
  var userModular = getModularInstance(user);
  if (!multiFactorUserCache.has(userModular)) {
    multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));
  }
  return multiFactorUserCache.get(userModular);
}
var name = "@firebase/auth";
var version = "1.5.1";
var AuthInterop = (
  /** @class */
  function() {
    function AuthInterop2(auth) {
      this.auth = auth;
      this.internalListeners = /* @__PURE__ */ new Map();
    }
    AuthInterop2.prototype.getUid = function() {
      var _a2;
      this.assertAuthConfigured();
      return ((_a2 = this.auth.currentUser) === null || _a2 === void 0 ? void 0 : _a2.uid) || null;
    };
    AuthInterop2.prototype.getToken = function(forceRefresh) {
      return __awaiter(this, void 0, void 0, function() {
        var accessToken;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.assertAuthConfigured();
              return [4, this.auth._initializationPromise];
            case 1:
              _a2.sent();
              if (!this.auth.currentUser) {
                return [2, null];
              }
              return [4, this.auth.currentUser.getIdToken(forceRefresh)];
            case 2:
              accessToken = _a2.sent();
              return [2, { accessToken }];
          }
        });
      });
    };
    AuthInterop2.prototype.addAuthTokenListener = function(listener) {
      this.assertAuthConfigured();
      if (this.internalListeners.has(listener)) {
        return;
      }
      var unsubscribe = this.auth.onIdTokenChanged(function(user) {
        listener((user === null || user === void 0 ? void 0 : user.stsTokenManager.accessToken) || null);
      });
      this.internalListeners.set(listener, unsubscribe);
      this.updateProactiveRefresh();
    };
    AuthInterop2.prototype.removeAuthTokenListener = function(listener) {
      this.assertAuthConfigured();
      var unsubscribe = this.internalListeners.get(listener);
      if (!unsubscribe) {
        return;
      }
      this.internalListeners.delete(listener);
      unsubscribe();
      this.updateProactiveRefresh();
    };
    AuthInterop2.prototype.assertAuthConfigured = function() {
      _assert(
        this.auth._initializationPromise,
        "dependent-sdk-initialized-before-auth"
        /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */
      );
    };
    AuthInterop2.prototype.updateProactiveRefresh = function() {
      if (this.internalListeners.size > 0) {
        this.auth._startProactiveRefresh();
      } else {
        this.auth._stopProactiveRefresh();
      }
    };
    return AuthInterop2;
  }()
);
function getVersionForPlatform(clientPlatform) {
  switch (clientPlatform) {
    case "Node":
      return "node";
    case "ReactNative":
      return "rn";
    case "Worker":
      return "webworker";
    case "Cordova":
      return "cordova";
    default:
      return void 0;
  }
}
function registerAuth(clientPlatform) {
  _registerComponent(new Component(
    "auth",
    function(container, _a2) {
      var deps = _a2.options;
      var app = container.getProvider("app").getImmediate();
      var heartbeatServiceProvider = container.getProvider("heartbeat");
      var appCheckServiceProvider = container.getProvider("app-check-internal");
      var _b = app.options, apiKey = _b.apiKey, authDomain = _b.authDomain;
      _assert(apiKey && !apiKey.includes(":"), "invalid-api-key", { appName: app.name });
      var config = {
        apiKey,
        authDomain,
        clientPlatform,
        apiHost: "identitytoolkit.googleapis.com",
        tokenApiHost: "securetoken.googleapis.com",
        apiScheme: "https",
        sdkClientVersion: _getClientVersion(clientPlatform)
      };
      var authInstance = new AuthImpl(app, heartbeatServiceProvider, appCheckServiceProvider, config);
      _initializeAuthInstance(authInstance, deps);
      return authInstance;
    },
    "PUBLIC"
    /* ComponentType.PUBLIC */
  ).setInstantiationMode(
    "EXPLICIT"
    /* InstantiationMode.EXPLICIT */
  ).setInstanceCreatedCallback(function(container, _instanceIdentifier, _instance) {
    var authInternalProvider = container.getProvider(
      "auth-internal"
      /* _ComponentName.AUTH_INTERNAL */
    );
    authInternalProvider.initialize();
  }));
  _registerComponent(new Component(
    "auth-internal",
    function(container) {
      var auth = _castAuth(container.getProvider(
        "auth"
        /* _ComponentName.AUTH */
      ).getImmediate());
      return function(auth2) {
        return new AuthInterop(auth2);
      }(auth);
    },
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ).setInstantiationMode(
    "EXPLICIT"
    /* InstantiationMode.EXPLICIT */
  ));
  registerVersion(name, version, getVersionForPlatform(clientPlatform));
  registerVersion(name, version, "esm5");
}
var FactorId = {
  /** Phone as second factor */
  PHONE: "phone",
  TOTP: "totp"
};
var ProviderId = {
  /** Facebook provider ID */
  FACEBOOK: "facebook.com",
  /** GitHub provider ID */
  GITHUB: "github.com",
  /** Google provider ID */
  GOOGLE: "google.com",
  /** Password provider */
  PASSWORD: "password",
  /** Phone provider */
  PHONE: "phone",
  /** Twitter provider ID */
  TWITTER: "twitter.com"
};
var SignInMethod = {
  /** Email link sign in method */
  EMAIL_LINK: "emailLink",
  /** Email/password sign in method */
  EMAIL_PASSWORD: "password",
  /** Facebook sign in method */
  FACEBOOK: "facebook.com",
  /** GitHub sign in method */
  GITHUB: "github.com",
  /** Google sign in method */
  GOOGLE: "google.com",
  /** Phone sign in method */
  PHONE: "phone",
  /** Twitter sign in method */
  TWITTER: "twitter.com"
};
var OperationType = {
  /** Operation involving linking an additional provider to an already signed-in user. */
  LINK: "link",
  /** Operation involving using a provider to reauthenticate an already signed-in user. */
  REAUTHENTICATE: "reauthenticate",
  /** Operation involving signing in a user. */
  SIGN_IN: "signIn"
};
var ActionCodeOperation = {
  /** The email link sign-in action. */
  EMAIL_SIGNIN: "EMAIL_SIGNIN",
  /** The password reset action. */
  PASSWORD_RESET: "PASSWORD_RESET",
  /** The email revocation action. */
  RECOVER_EMAIL: "RECOVER_EMAIL",
  /** The revert second factor addition email action. */
  REVERT_SECOND_FACTOR_ADDITION: "REVERT_SECOND_FACTOR_ADDITION",
  /** The revert second factor addition email action. */
  VERIFY_AND_CHANGE_EMAIL: "VERIFY_AND_CHANGE_EMAIL",
  /** The email verification action. */
  VERIFY_EMAIL: "VERIFY_EMAIL"
};
var BrowserPersistenceClass = (
  /** @class */
  function() {
    function BrowserPersistenceClass2(storageRetriever, type) {
      this.storageRetriever = storageRetriever;
      this.type = type;
    }
    BrowserPersistenceClass2.prototype._isAvailable = function() {
      try {
        if (!this.storage) {
          return Promise.resolve(false);
        }
        this.storage.setItem(STORAGE_AVAILABLE_KEY, "1");
        this.storage.removeItem(STORAGE_AVAILABLE_KEY);
        return Promise.resolve(true);
      } catch (_a2) {
        return Promise.resolve(false);
      }
    };
    BrowserPersistenceClass2.prototype._set = function(key, value) {
      this.storage.setItem(key, JSON.stringify(value));
      return Promise.resolve();
    };
    BrowserPersistenceClass2.prototype._get = function(key) {
      var json = this.storage.getItem(key);
      return Promise.resolve(json ? JSON.parse(json) : null);
    };
    BrowserPersistenceClass2.prototype._remove = function(key) {
      this.storage.removeItem(key);
      return Promise.resolve();
    };
    Object.defineProperty(BrowserPersistenceClass2.prototype, "storage", {
      get: function() {
        return this.storageRetriever();
      },
      enumerable: false,
      configurable: true
    });
    return BrowserPersistenceClass2;
  }()
);
function _iframeCannotSyncWebStorage() {
  var ua = getUA();
  return _isSafari(ua) || _isIOS(ua);
}
var _POLLING_INTERVAL_MS = 1e3;
var IE10_LOCAL_STORAGE_SYNC_DELAY = 10;
var BrowserLocalPersistence = (
  /** @class */
  function(_super) {
    __extends(BrowserLocalPersistence2, _super);
    function BrowserLocalPersistence2() {
      var _this = _super.call(
        this,
        function() {
          return window.localStorage;
        },
        "LOCAL"
        /* PersistenceType.LOCAL */
      ) || this;
      _this.boundEventHandler = function(event, poll) {
        return _this.onStorageEvent(event, poll);
      };
      _this.listeners = {};
      _this.localCache = {};
      _this.pollTimer = null;
      _this.safariLocalStorageNotSynced = _iframeCannotSyncWebStorage() && _isIframe();
      _this.fallbackToPolling = _isMobileBrowser();
      _this._shouldAllowMigration = true;
      return _this;
    }
    BrowserLocalPersistence2.prototype.forAllChangedKeys = function(cb) {
      for (var _i = 0, _a2 = Object.keys(this.listeners); _i < _a2.length; _i++) {
        var key = _a2[_i];
        var newValue = this.storage.getItem(key);
        var oldValue = this.localCache[key];
        if (newValue !== oldValue) {
          cb(key, oldValue, newValue);
        }
      }
    };
    BrowserLocalPersistence2.prototype.onStorageEvent = function(event, poll) {
      var _this = this;
      if (poll === void 0) {
        poll = false;
      }
      if (!event.key) {
        this.forAllChangedKeys(function(key2, _oldValue, newValue) {
          _this.notifyListeners(key2, newValue);
        });
        return;
      }
      var key = event.key;
      if (poll) {
        this.detachListener();
      } else {
        this.stopPolling();
      }
      if (this.safariLocalStorageNotSynced) {
        var storedValue_1 = this.storage.getItem(key);
        if (event.newValue !== storedValue_1) {
          if (event.newValue !== null) {
            this.storage.setItem(key, event.newValue);
          } else {
            this.storage.removeItem(key);
          }
        } else if (this.localCache[key] === event.newValue && !poll) {
          return;
        }
      }
      var triggerListeners = function() {
        var storedValue2 = _this.storage.getItem(key);
        if (!poll && _this.localCache[key] === storedValue2) {
          return;
        }
        _this.notifyListeners(key, storedValue2);
      };
      var storedValue = this.storage.getItem(key);
      if (_isIE10() && storedValue !== event.newValue && event.newValue !== event.oldValue) {
        setTimeout(triggerListeners, IE10_LOCAL_STORAGE_SYNC_DELAY);
      } else {
        triggerListeners();
      }
    };
    BrowserLocalPersistence2.prototype.notifyListeners = function(key, value) {
      this.localCache[key] = value;
      var listeners = this.listeners[key];
      if (listeners) {
        for (var _i = 0, _a2 = Array.from(listeners); _i < _a2.length; _i++) {
          var listener = _a2[_i];
          listener(value ? JSON.parse(value) : value);
        }
      }
    };
    BrowserLocalPersistence2.prototype.startPolling = function() {
      var _this = this;
      this.stopPolling();
      this.pollTimer = setInterval(function() {
        _this.forAllChangedKeys(function(key, oldValue, newValue) {
          _this.onStorageEvent(
            new StorageEvent("storage", {
              key,
              oldValue,
              newValue
            }),
            /* poll */
            true
          );
        });
      }, _POLLING_INTERVAL_MS);
    };
    BrowserLocalPersistence2.prototype.stopPolling = function() {
      if (this.pollTimer) {
        clearInterval(this.pollTimer);
        this.pollTimer = null;
      }
    };
    BrowserLocalPersistence2.prototype.attachListener = function() {
      window.addEventListener("storage", this.boundEventHandler);
    };
    BrowserLocalPersistence2.prototype.detachListener = function() {
      window.removeEventListener("storage", this.boundEventHandler);
    };
    BrowserLocalPersistence2.prototype._addListener = function(key, listener) {
      if (Object.keys(this.listeners).length === 0) {
        if (this.fallbackToPolling) {
          this.startPolling();
        } else {
          this.attachListener();
        }
      }
      if (!this.listeners[key]) {
        this.listeners[key] = /* @__PURE__ */ new Set();
        this.localCache[key] = this.storage.getItem(key);
      }
      this.listeners[key].add(listener);
    };
    BrowserLocalPersistence2.prototype._removeListener = function(key, listener) {
      if (this.listeners[key]) {
        this.listeners[key].delete(listener);
        if (this.listeners[key].size === 0) {
          delete this.listeners[key];
        }
      }
      if (Object.keys(this.listeners).length === 0) {
        this.detachListener();
        this.stopPolling();
      }
    };
    BrowserLocalPersistence2.prototype._set = function(key, value) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, _super.prototype._set.call(this, key, value)];
            case 1:
              _a2.sent();
              this.localCache[key] = JSON.stringify(value);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    BrowserLocalPersistence2.prototype._get = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        var value;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, _super.prototype._get.call(this, key)];
            case 1:
              value = _a2.sent();
              this.localCache[key] = JSON.stringify(value);
              return [2, value];
          }
        });
      });
    };
    BrowserLocalPersistence2.prototype._remove = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, _super.prototype._remove.call(this, key)];
            case 1:
              _a2.sent();
              delete this.localCache[key];
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    BrowserLocalPersistence2.type = "LOCAL";
    return BrowserLocalPersistence2;
  }(BrowserPersistenceClass)
);
var browserLocalPersistence = BrowserLocalPersistence;
var BrowserSessionPersistence = (
  /** @class */
  function(_super) {
    __extends(BrowserSessionPersistence2, _super);
    function BrowserSessionPersistence2() {
      return _super.call(
        this,
        function() {
          return window.sessionStorage;
        },
        "SESSION"
        /* PersistenceType.SESSION */
      ) || this;
    }
    BrowserSessionPersistence2.prototype._addListener = function(_key, _listener) {
      return;
    };
    BrowserSessionPersistence2.prototype._removeListener = function(_key, _listener) {
      return;
    };
    BrowserSessionPersistence2.type = "SESSION";
    return BrowserSessionPersistence2;
  }(BrowserPersistenceClass)
);
var browserSessionPersistence = BrowserSessionPersistence;
function _withDefaultResolver(auth, resolverOverride) {
  if (resolverOverride) {
    return _getInstance(resolverOverride);
  }
  _assert(
    auth._popupRedirectResolver,
    auth,
    "argument-error"
    /* AuthErrorCode.ARGUMENT_ERROR */
  );
  return auth._popupRedirectResolver;
}
var IdpCredential = (
  /** @class */
  function(_super) {
    __extends(IdpCredential2, _super);
    function IdpCredential2(params) {
      var _this = _super.call(
        this,
        "custom",
        "custom"
        /* ProviderId.CUSTOM */
      ) || this;
      _this.params = params;
      return _this;
    }
    IdpCredential2.prototype._getIdTokenResponse = function(auth) {
      return signInWithIdp(auth, this._buildIdpRequest());
    };
    IdpCredential2.prototype._linkToIdToken = function(auth, idToken) {
      return signInWithIdp(auth, this._buildIdpRequest(idToken));
    };
    IdpCredential2.prototype._getReauthenticationResolver = function(auth) {
      return signInWithIdp(auth, this._buildIdpRequest());
    };
    IdpCredential2.prototype._buildIdpRequest = function(idToken) {
      var request = {
        requestUri: this.params.requestUri,
        sessionId: this.params.sessionId,
        postBody: this.params.postBody,
        tenantId: this.params.tenantId,
        pendingToken: this.params.pendingToken,
        returnSecureToken: true,
        returnIdpCredential: true
      };
      if (idToken) {
        request.idToken = idToken;
      }
      return request;
    };
    return IdpCredential2;
  }(AuthCredential)
);
function _signIn(params) {
  return _signInWithCredential(params.auth, new IdpCredential(params), params.bypassAuthState);
}
function _reauth(params) {
  var auth = params.auth, user = params.user;
  _assert(
    user,
    auth,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  return _reauthenticate(user, new IdpCredential(params), params.bypassAuthState);
}
function _link(params) {
  return __awaiter(this, void 0, void 0, function() {
    var auth, user;
    return __generator(this, function(_a2) {
      auth = params.auth, user = params.user;
      _assert(
        user,
        auth,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      return [2, _link$1(user, new IdpCredential(params), params.bypassAuthState)];
    });
  });
}
var AbstractPopupRedirectOperation = (
  /** @class */
  function() {
    function AbstractPopupRedirectOperation2(auth, filter, resolver, user, bypassAuthState) {
      if (bypassAuthState === void 0) {
        bypassAuthState = false;
      }
      this.auth = auth;
      this.resolver = resolver;
      this.user = user;
      this.bypassAuthState = bypassAuthState;
      this.pendingPromise = null;
      this.eventManager = null;
      this.filter = Array.isArray(filter) ? filter : [filter];
    }
    AbstractPopupRedirectOperation2.prototype.execute = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        return __awaiter(_this, void 0, void 0, function() {
          var _a2, e_1;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                this.pendingPromise = { resolve, reject };
                _b.label = 1;
              case 1:
                _b.trys.push([1, 4, , 5]);
                _a2 = this;
                return [4, this.resolver._initialize(this.auth)];
              case 2:
                _a2.eventManager = _b.sent();
                return [4, this.onExecution()];
              case 3:
                _b.sent();
                this.eventManager.registerConsumer(this);
                return [3, 5];
              case 4:
                e_1 = _b.sent();
                this.reject(e_1);
                return [3, 5];
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    };
    AbstractPopupRedirectOperation2.prototype.onAuthEvent = function(event) {
      return __awaiter(this, void 0, void 0, function() {
        var urlResponse, sessionId, postBody, tenantId, error, type, params, _a2, e_2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              urlResponse = event.urlResponse, sessionId = event.sessionId, postBody = event.postBody, tenantId = event.tenantId, error = event.error, type = event.type;
              if (error) {
                this.reject(error);
                return [
                  2
                  /*return*/
                ];
              }
              params = {
                auth: this.auth,
                requestUri: urlResponse,
                sessionId,
                tenantId: tenantId || void 0,
                postBody: postBody || void 0,
                user: this.user,
                bypassAuthState: this.bypassAuthState
              };
              _b.label = 1;
            case 1:
              _b.trys.push([1, 3, , 4]);
              _a2 = this.resolve;
              return [4, this.getIdpTask(type)(params)];
            case 2:
              _a2.apply(this, [_b.sent()]);
              return [3, 4];
            case 3:
              e_2 = _b.sent();
              this.reject(e_2);
              return [3, 4];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    AbstractPopupRedirectOperation2.prototype.onError = function(error) {
      this.reject(error);
    };
    AbstractPopupRedirectOperation2.prototype.getIdpTask = function(type) {
      switch (type) {
        case "signInViaPopup":
        case "signInViaRedirect":
          return _signIn;
        case "linkViaPopup":
        case "linkViaRedirect":
          return _link;
        case "reauthViaPopup":
        case "reauthViaRedirect":
          return _reauth;
        default:
          _fail(
            this.auth,
            "internal-error"
            /* AuthErrorCode.INTERNAL_ERROR */
          );
      }
    };
    AbstractPopupRedirectOperation2.prototype.resolve = function(cred) {
      debugAssert(this.pendingPromise, "Pending promise was never set");
      this.pendingPromise.resolve(cred);
      this.unregisterAndCleanUp();
    };
    AbstractPopupRedirectOperation2.prototype.reject = function(error) {
      debugAssert(this.pendingPromise, "Pending promise was never set");
      this.pendingPromise.reject(error);
      this.unregisterAndCleanUp();
    };
    AbstractPopupRedirectOperation2.prototype.unregisterAndCleanUp = function() {
      if (this.eventManager) {
        this.eventManager.unregisterConsumer(this);
      }
      this.pendingPromise = null;
      this.cleanUp();
    };
    return AbstractPopupRedirectOperation2;
  }()
);
var PENDING_REDIRECT_KEY = "pendingRedirect";
var redirectOutcomeMap = /* @__PURE__ */ new Map();
var RedirectAction = (
  /** @class */
  function(_super) {
    __extends(RedirectAction2, _super);
    function RedirectAction2(auth, resolver, bypassAuthState) {
      if (bypassAuthState === void 0) {
        bypassAuthState = false;
      }
      var _this = _super.call(this, auth, [
        "signInViaRedirect",
        "linkViaRedirect",
        "reauthViaRedirect",
        "unknown"
        /* AuthEventType.UNKNOWN */
      ], resolver, void 0, bypassAuthState) || this;
      _this.eventId = null;
      return _this;
    }
    RedirectAction2.prototype.execute = function() {
      return __awaiter(this, void 0, void 0, function() {
        var readyOutcome, hasPendingRedirect, result_1, _a2, e_1;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              readyOutcome = redirectOutcomeMap.get(this.auth._key());
              if (!!readyOutcome)
                return [3, 8];
              _b.label = 1;
            case 1:
              _b.trys.push([1, 6, , 7]);
              return [4, _getAndClearPendingRedirectStatus(this.resolver, this.auth)];
            case 2:
              hasPendingRedirect = _b.sent();
              if (!hasPendingRedirect)
                return [3, 4];
              return [4, _super.prototype.execute.call(this)];
            case 3:
              _a2 = _b.sent();
              return [3, 5];
            case 4:
              _a2 = null;
              _b.label = 5;
            case 5:
              result_1 = _a2;
              readyOutcome = function() {
                return Promise.resolve(result_1);
              };
              return [3, 7];
            case 6:
              e_1 = _b.sent();
              readyOutcome = function() {
                return Promise.reject(e_1);
              };
              return [3, 7];
            case 7:
              redirectOutcomeMap.set(this.auth._key(), readyOutcome);
              _b.label = 8;
            case 8:
              if (!this.bypassAuthState) {
                redirectOutcomeMap.set(this.auth._key(), function() {
                  return Promise.resolve(null);
                });
              }
              return [2, readyOutcome()];
          }
        });
      });
    };
    RedirectAction2.prototype.onAuthEvent = function(event) {
      return __awaiter(this, void 0, void 0, function() {
        var user;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (event.type === "signInViaRedirect") {
                return [2, _super.prototype.onAuthEvent.call(this, event)];
              } else if (event.type === "unknown") {
                this.resolve(null);
                return [
                  2
                  /*return*/
                ];
              }
              if (!event.eventId)
                return [3, 2];
              return [4, this.auth._redirectUserForId(event.eventId)];
            case 1:
              user = _a2.sent();
              if (user) {
                this.user = user;
                return [2, _super.prototype.onAuthEvent.call(this, event)];
              } else {
                this.resolve(null);
              }
              _a2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    RedirectAction2.prototype.onExecution = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          return [
            2
            /*return*/
          ];
        });
      });
    };
    RedirectAction2.prototype.cleanUp = function() {
    };
    return RedirectAction2;
  }(AbstractPopupRedirectOperation)
);
function _getAndClearPendingRedirectStatus(resolver, auth) {
  return __awaiter(this, void 0, void 0, function() {
    var key, persistence, hasPendingRedirect;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          key = pendingRedirectKey(auth);
          persistence = resolverPersistence(resolver);
          return [4, persistence._isAvailable()];
        case 1:
          if (!_a2.sent()) {
            return [2, false];
          }
          return [4, persistence._get(key)];
        case 2:
          hasPendingRedirect = _a2.sent() === "true";
          return [4, persistence._remove(key)];
        case 3:
          _a2.sent();
          return [2, hasPendingRedirect];
      }
    });
  });
}
function _setPendingRedirectStatus(resolver, auth) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, resolverPersistence(resolver)._set(pendingRedirectKey(auth), "true")];
    });
  });
}
function _clearRedirectOutcomes() {
  redirectOutcomeMap.clear();
}
function _overrideRedirectResult(auth, result) {
  redirectOutcomeMap.set(auth._key(), result);
}
function resolverPersistence(resolver) {
  return _getInstance(resolver._redirectPersistence);
}
function pendingRedirectKey(auth) {
  return _persistenceKeyName(PENDING_REDIRECT_KEY, auth.config.apiKey, auth.name);
}
function _signInWithRedirect(auth, provider, resolver) {
  return __awaiter(this, void 0, void 0, function() {
    var authInternal, resolverInternal;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          authInternal = _castAuth(auth);
          _assertInstanceOf(auth, provider, FederatedAuthProvider);
          return [4, authInternal._initializationPromise];
        case 1:
          _a2.sent();
          resolverInternal = _withDefaultResolver(authInternal, resolver);
          return [4, _setPendingRedirectStatus(resolverInternal, authInternal)];
        case 2:
          _a2.sent();
          return [2, resolverInternal._openRedirect(
            authInternal,
            provider,
            "signInViaRedirect"
            /* AuthEventType.SIGN_IN_VIA_REDIRECT */
          )];
      }
    });
  });
}
function _reauthenticateWithRedirect(user, provider, resolver) {
  return __awaiter(this, void 0, void 0, function() {
    var userInternal, resolverInternal, eventId;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          userInternal = getModularInstance(user);
          _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
          return [4, userInternal.auth._initializationPromise];
        case 1:
          _a2.sent();
          resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
          return [4, _setPendingRedirectStatus(resolverInternal, userInternal.auth)];
        case 2:
          _a2.sent();
          return [4, prepareUserForRedirect(userInternal)];
        case 3:
          eventId = _a2.sent();
          return [2, resolverInternal._openRedirect(userInternal.auth, provider, "reauthViaRedirect", eventId)];
      }
    });
  });
}
function _linkWithRedirect(user, provider, resolver) {
  return __awaiter(this, void 0, void 0, function() {
    var userInternal, resolverInternal, eventId;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          userInternal = getModularInstance(user);
          _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
          return [4, userInternal.auth._initializationPromise];
        case 1:
          _a2.sent();
          resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
          return [4, _assertLinkedStatus(false, userInternal, provider.providerId)];
        case 2:
          _a2.sent();
          return [4, _setPendingRedirectStatus(resolverInternal, userInternal.auth)];
        case 3:
          _a2.sent();
          return [4, prepareUserForRedirect(userInternal)];
        case 4:
          eventId = _a2.sent();
          return [2, resolverInternal._openRedirect(userInternal.auth, provider, "linkViaRedirect", eventId)];
      }
    });
  });
}
function getRedirectResult(auth, resolver) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, _castAuth(auth)._initializationPromise];
        case 1:
          _a2.sent();
          return [2, _getRedirectResult(auth, resolver, false)];
      }
    });
  });
}
function _getRedirectResult(auth, resolverExtern, bypassAuthState) {
  if (bypassAuthState === void 0) {
    bypassAuthState = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var authInternal, resolver, action, result;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          authInternal = _castAuth(auth);
          resolver = _withDefaultResolver(authInternal, resolverExtern);
          action = new RedirectAction(authInternal, resolver, bypassAuthState);
          return [4, action.execute()];
        case 1:
          result = _a2.sent();
          if (!(result && !bypassAuthState))
            return [3, 4];
          delete result.user._redirectEventId;
          return [4, authInternal._persistUserIfCurrent(result.user)];
        case 2:
          _a2.sent();
          return [4, authInternal._setRedirectUser(null, resolverExtern)];
        case 3:
          _a2.sent();
          _a2.label = 4;
        case 4:
          return [2, result];
      }
    });
  });
}
function prepareUserForRedirect(user) {
  return __awaiter(this, void 0, void 0, function() {
    var eventId;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          eventId = _generateEventId("".concat(user.uid, ":::"));
          user._redirectEventId = eventId;
          return [4, user.auth._setRedirectUser(user)];
        case 1:
          _a2.sent();
          return [4, user.auth._persistUserIfCurrent(user)];
        case 2:
          _a2.sent();
          return [2, eventId];
      }
    });
  });
}
var WIDGET_PATH = "__/auth/handler";
var EMULATOR_WIDGET_PATH = "emulator/auth/handler";
var FIREBASE_APP_CHECK_FRAGMENT_ID = encodeURIComponent("fac");
function _getRedirectUrl(auth, provider, authType, redirectUrl, eventId, additionalParams) {
  return __awaiter(this, void 0, void 0, function() {
    var params, _i, _a2, _b, key, value, scopes, paramsDict, _c, _d, key, appCheckToken, appCheckTokenFragment;
    return __generator(this, function(_e) {
      switch (_e.label) {
        case 0:
          _assert(
            auth.config.authDomain,
            auth,
            "auth-domain-config-required"
            /* AuthErrorCode.MISSING_AUTH_DOMAIN */
          );
          _assert(
            auth.config.apiKey,
            auth,
            "invalid-api-key"
            /* AuthErrorCode.INVALID_API_KEY */
          );
          params = {
            apiKey: auth.config.apiKey,
            appName: auth.name,
            authType,
            redirectUrl,
            v: SDK_VERSION,
            eventId
          };
          if (provider instanceof FederatedAuthProvider) {
            provider.setDefaultLanguage(auth.languageCode);
            params.providerId = provider.providerId || "";
            if (!isEmpty(provider.getCustomParameters())) {
              params.customParameters = JSON.stringify(provider.getCustomParameters());
            }
            for (_i = 0, _a2 = Object.entries(additionalParams || {}); _i < _a2.length; _i++) {
              _b = _a2[_i], key = _b[0], value = _b[1];
              params[key] = value;
            }
          }
          if (provider instanceof BaseOAuthProvider) {
            scopes = provider.getScopes().filter(function(scope) {
              return scope !== "";
            });
            if (scopes.length > 0) {
              params.scopes = scopes.join(",");
            }
          }
          if (auth.tenantId) {
            params.tid = auth.tenantId;
          }
          paramsDict = params;
          for (_c = 0, _d = Object.keys(paramsDict); _c < _d.length; _c++) {
            key = _d[_c];
            if (paramsDict[key] === void 0) {
              delete paramsDict[key];
            }
          }
          return [4, auth._getAppCheckToken()];
        case 1:
          appCheckToken = _e.sent();
          appCheckTokenFragment = appCheckToken ? "#".concat(FIREBASE_APP_CHECK_FRAGMENT_ID, "=").concat(encodeURIComponent(appCheckToken)) : "";
          return [2, "".concat(getHandlerBase(auth), "?").concat(querystring(paramsDict).slice(1)).concat(appCheckTokenFragment)];
      }
    });
  });
}
function getHandlerBase(_a2) {
  var config = _a2.config;
  if (!config.emulator) {
    return "https://".concat(config.authDomain, "/").concat(WIDGET_PATH);
  }
  return _emulatorUrl(config, EMULATOR_WIDGET_PATH);
}
function _cordovaWindow() {
  return window;
}
function _getProjectConfig(auth, request) {
  if (request === void 0) {
    request = {};
  }
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, _performApiRequest(auth, "GET", "/v1/projects", request)];
    });
  });
}
var REDIRECT_TIMEOUT_MS = 2e3;
function _generateHandlerUrl(auth, event, provider) {
  var _a2;
  return __awaiter(this, void 0, void 0, function() {
    var BuildInfo, sessionDigest, additionalParams;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          BuildInfo = _cordovaWindow().BuildInfo;
          debugAssert(event.sessionId, "AuthEvent did not contain a session ID");
          return [4, computeSha256(event.sessionId)];
        case 1:
          sessionDigest = _b.sent();
          additionalParams = {};
          if (_isIOS()) {
            additionalParams["ibi"] = BuildInfo.packageName;
          } else if (_isAndroid()) {
            additionalParams["apn"] = BuildInfo.packageName;
          } else {
            _fail(
              auth,
              "operation-not-supported-in-this-environment"
              /* AuthErrorCode.OPERATION_NOT_SUPPORTED */
            );
          }
          if (BuildInfo.displayName) {
            additionalParams["appDisplayName"] = BuildInfo.displayName;
          }
          additionalParams["sessionId"] = sessionDigest;
          return [2, _getRedirectUrl(auth, provider, event.type, void 0, (_a2 = event.eventId) !== null && _a2 !== void 0 ? _a2 : void 0, additionalParams)];
      }
    });
  });
}
function _validateOrigin(auth) {
  return __awaiter(this, void 0, void 0, function() {
    var BuildInfo, request;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          BuildInfo = _cordovaWindow().BuildInfo;
          request = {};
          if (_isIOS()) {
            request.iosBundleId = BuildInfo.packageName;
          } else if (_isAndroid()) {
            request.androidPackageName = BuildInfo.packageName;
          } else {
            _fail(
              auth,
              "operation-not-supported-in-this-environment"
              /* AuthErrorCode.OPERATION_NOT_SUPPORTED */
            );
          }
          return [4, _getProjectConfig(auth, request)];
        case 1:
          _a2.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function _performRedirect(handlerUrl) {
  var cordova = _cordovaWindow().cordova;
  return new Promise(function(resolve) {
    cordova.plugins.browsertab.isAvailable(function(browserTabIsAvailable) {
      var iabRef = null;
      if (browserTabIsAvailable) {
        cordova.plugins.browsertab.openUrl(handlerUrl);
      } else {
        iabRef = cordova.InAppBrowser.open(handlerUrl, _isIOS7Or8() ? "_blank" : "_system", "location=yes");
      }
      resolve(iabRef);
    });
  });
}
function _waitForAppResume(auth, eventListener, iabRef) {
  return __awaiter(this, void 0, void 0, function() {
    var cordova, cleanup;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          cordova = _cordovaWindow().cordova;
          cleanup = function() {
          };
          _a2.label = 1;
        case 1:
          _a2.trys.push([1, , 3, 4]);
          return [4, new Promise(function(resolve, reject) {
            var onCloseTimer = null;
            function authEventSeen() {
              var _a3;
              resolve();
              var closeBrowserTab = (_a3 = cordova.plugins.browsertab) === null || _a3 === void 0 ? void 0 : _a3.close;
              if (typeof closeBrowserTab === "function") {
                closeBrowserTab();
              }
              if (typeof (iabRef === null || iabRef === void 0 ? void 0 : iabRef.close) === "function") {
                iabRef.close();
              }
            }
            function resumed() {
              if (onCloseTimer) {
                return;
              }
              onCloseTimer = window.setTimeout(function() {
                reject(_createError(
                  auth,
                  "redirect-cancelled-by-user"
                  /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */
                ));
              }, REDIRECT_TIMEOUT_MS);
            }
            function visibilityChanged() {
              if ((document === null || document === void 0 ? void 0 : document.visibilityState) === "visible") {
                resumed();
              }
            }
            eventListener.addPassiveListener(authEventSeen);
            document.addEventListener("resume", resumed, false);
            if (_isAndroid()) {
              document.addEventListener("visibilitychange", visibilityChanged, false);
            }
            cleanup = function() {
              eventListener.removePassiveListener(authEventSeen);
              document.removeEventListener("resume", resumed, false);
              document.removeEventListener("visibilitychange", visibilityChanged, false);
              if (onCloseTimer) {
                window.clearTimeout(onCloseTimer);
              }
            };
          })];
        case 2:
          _a2.sent();
          return [3, 4];
        case 3:
          cleanup();
          return [
            7
            /*endfinally*/
          ];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function _checkCordovaConfiguration(auth) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  var win = _cordovaWindow();
  _assert(typeof ((_a2 = win === null || win === void 0 ? void 0 : win.universalLinks) === null || _a2 === void 0 ? void 0 : _a2.subscribe) === "function", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-universal-links-plugin-fix"
  });
  _assert(typeof ((_b = win === null || win === void 0 ? void 0 : win.BuildInfo) === null || _b === void 0 ? void 0 : _b.packageName) !== "undefined", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-buildInfo"
  });
  _assert(typeof ((_e = (_d = (_c = win === null || win === void 0 ? void 0 : win.cordova) === null || _c === void 0 ? void 0 : _c.plugins) === null || _d === void 0 ? void 0 : _d.browsertab) === null || _e === void 0 ? void 0 : _e.openUrl) === "function", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-browsertab"
  });
  _assert(typeof ((_h = (_g = (_f = win === null || win === void 0 ? void 0 : win.cordova) === null || _f === void 0 ? void 0 : _f.plugins) === null || _g === void 0 ? void 0 : _g.browsertab) === null || _h === void 0 ? void 0 : _h.isAvailable) === "function", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-browsertab"
  });
  _assert(typeof ((_k = (_j = win === null || win === void 0 ? void 0 : win.cordova) === null || _j === void 0 ? void 0 : _j.InAppBrowser) === null || _k === void 0 ? void 0 : _k.open) === "function", auth, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-inappbrowser"
  });
}
function computeSha256(sessionId) {
  return __awaiter(this, void 0, void 0, function() {
    var bytes, buf, arr;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          bytes = stringToArrayBuffer(sessionId);
          return [4, crypto.subtle.digest("SHA-256", bytes)];
        case 1:
          buf = _a2.sent();
          arr = Array.from(new Uint8Array(buf));
          return [2, arr.map(function(num) {
            return num.toString(16).padStart(2, "0");
          }).join("")];
      }
    });
  });
}
function stringToArrayBuffer(str) {
  debugAssert(/[0-9a-zA-Z]+/.test(str), "Can only convert alpha-numeric strings");
  if (typeof TextEncoder !== "undefined") {
    return new TextEncoder().encode(str);
  }
  var buff = new ArrayBuffer(str.length);
  var view = new Uint8Array(buff);
  for (var i = 0; i < str.length; i++) {
    view[i] = str.charCodeAt(i);
  }
  return view;
}
var EVENT_DUPLICATION_CACHE_DURATION_MS = 10 * 60 * 1e3;
var AuthEventManager = (
  /** @class */
  function() {
    function AuthEventManager2(auth) {
      this.auth = auth;
      this.cachedEventUids = /* @__PURE__ */ new Set();
      this.consumers = /* @__PURE__ */ new Set();
      this.queuedRedirectEvent = null;
      this.hasHandledPotentialRedirect = false;
      this.lastProcessedEventTime = Date.now();
    }
    AuthEventManager2.prototype.registerConsumer = function(authEventConsumer) {
      this.consumers.add(authEventConsumer);
      if (this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, authEventConsumer)) {
        this.sendToConsumer(this.queuedRedirectEvent, authEventConsumer);
        this.saveEventToCache(this.queuedRedirectEvent);
        this.queuedRedirectEvent = null;
      }
    };
    AuthEventManager2.prototype.unregisterConsumer = function(authEventConsumer) {
      this.consumers.delete(authEventConsumer);
    };
    AuthEventManager2.prototype.onEvent = function(event) {
      var _this = this;
      if (this.hasEventBeenHandled(event)) {
        return false;
      }
      var handled = false;
      this.consumers.forEach(function(consumer) {
        if (_this.isEventForConsumer(event, consumer)) {
          handled = true;
          _this.sendToConsumer(event, consumer);
          _this.saveEventToCache(event);
        }
      });
      if (this.hasHandledPotentialRedirect || !isRedirectEvent(event)) {
        return handled;
      }
      this.hasHandledPotentialRedirect = true;
      if (!handled) {
        this.queuedRedirectEvent = event;
        handled = true;
      }
      return handled;
    };
    AuthEventManager2.prototype.sendToConsumer = function(event, consumer) {
      var _a2;
      if (event.error && !isNullRedirectEvent(event)) {
        var code = ((_a2 = event.error.code) === null || _a2 === void 0 ? void 0 : _a2.split("auth/")[1]) || "internal-error";
        consumer.onError(_createError(this.auth, code));
      } else {
        consumer.onAuthEvent(event);
      }
    };
    AuthEventManager2.prototype.isEventForConsumer = function(event, consumer) {
      var eventIdMatches = consumer.eventId === null || !!event.eventId && event.eventId === consumer.eventId;
      return consumer.filter.includes(event.type) && eventIdMatches;
    };
    AuthEventManager2.prototype.hasEventBeenHandled = function(event) {
      if (Date.now() - this.lastProcessedEventTime >= EVENT_DUPLICATION_CACHE_DURATION_MS) {
        this.cachedEventUids.clear();
      }
      return this.cachedEventUids.has(eventUid(event));
    };
    AuthEventManager2.prototype.saveEventToCache = function(event) {
      this.cachedEventUids.add(eventUid(event));
      this.lastProcessedEventTime = Date.now();
    };
    return AuthEventManager2;
  }()
);
function eventUid(e) {
  return [e.type, e.eventId, e.sessionId, e.tenantId].filter(function(v) {
    return v;
  }).join("-");
}
function isNullRedirectEvent(_a2) {
  var type = _a2.type, error = _a2.error;
  return type === "unknown" && (error === null || error === void 0 ? void 0 : error.code) === "auth/".concat(
    "no-auth-event"
    /* AuthErrorCode.NO_AUTH_EVENT */
  );
}
function isRedirectEvent(event) {
  switch (event.type) {
    case "signInViaRedirect":
    case "linkViaRedirect":
    case "reauthViaRedirect":
      return true;
    case "unknown":
      return isNullRedirectEvent(event);
    default:
      return false;
  }
}
var SESSION_ID_LENGTH = 20;
var CordovaAuthEventManager = (
  /** @class */
  function(_super) {
    __extends(CordovaAuthEventManager2, _super);
    function CordovaAuthEventManager2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.passiveListeners = /* @__PURE__ */ new Set();
      _this.initPromise = new Promise(function(resolve) {
        _this.resolveInialized = resolve;
      });
      return _this;
    }
    CordovaAuthEventManager2.prototype.addPassiveListener = function(cb) {
      this.passiveListeners.add(cb);
    };
    CordovaAuthEventManager2.prototype.removePassiveListener = function(cb) {
      this.passiveListeners.delete(cb);
    };
    CordovaAuthEventManager2.prototype.resetRedirect = function() {
      this.queuedRedirectEvent = null;
      this.hasHandledPotentialRedirect = false;
    };
    CordovaAuthEventManager2.prototype.onEvent = function(event) {
      this.resolveInialized();
      this.passiveListeners.forEach(function(cb) {
        return cb(event);
      });
      return _super.prototype.onEvent.call(this, event);
    };
    CordovaAuthEventManager2.prototype.initialized = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.initPromise];
            case 1:
              _a2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    return CordovaAuthEventManager2;
  }(AuthEventManager)
);
function _generateNewEvent(auth, type, eventId) {
  if (eventId === void 0) {
    eventId = null;
  }
  return {
    type,
    eventId,
    urlResponse: null,
    sessionId: generateSessionId(),
    postBody: null,
    tenantId: auth.tenantId,
    error: _createError(
      auth,
      "no-auth-event"
      /* AuthErrorCode.NO_AUTH_EVENT */
    )
  };
}
function _savePartialEvent(auth, event) {
  return storage()._set(persistenceKey(auth), event);
}
function _getAndRemoveEvent(auth) {
  return __awaiter(this, void 0, void 0, function() {
    var event;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, storage()._get(persistenceKey(auth))];
        case 1:
          event = _a2.sent();
          if (!event)
            return [3, 3];
          return [4, storage()._remove(persistenceKey(auth))];
        case 2:
          _a2.sent();
          _a2.label = 3;
        case 3:
          return [2, event];
      }
    });
  });
}
function _eventFromPartialAndUrl(partialEvent, url) {
  var _a2, _b;
  var callbackUrl = _getDeepLinkFromCallback(url);
  if (callbackUrl.includes("/__/auth/callback")) {
    var params = searchParamsOrEmpty(callbackUrl);
    var errorObject = params["firebaseError"] ? parseJsonOrNull(decodeURIComponent(params["firebaseError"])) : null;
    var code = (_b = (_a2 = errorObject === null || errorObject === void 0 ? void 0 : errorObject["code"]) === null || _a2 === void 0 ? void 0 : _a2.split("auth/")) === null || _b === void 0 ? void 0 : _b[1];
    var error = code ? _createError(code) : null;
    if (error) {
      return {
        type: partialEvent.type,
        eventId: partialEvent.eventId,
        tenantId: partialEvent.tenantId,
        error,
        urlResponse: null,
        sessionId: null,
        postBody: null
      };
    } else {
      return {
        type: partialEvent.type,
        eventId: partialEvent.eventId,
        tenantId: partialEvent.tenantId,
        sessionId: partialEvent.sessionId,
        urlResponse: callbackUrl,
        postBody: null
      };
    }
  }
  return null;
}
function generateSessionId() {
  var chars = [];
  var allowedChars = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  for (var i = 0; i < SESSION_ID_LENGTH; i++) {
    var idx = Math.floor(Math.random() * allowedChars.length);
    chars.push(allowedChars.charAt(idx));
  }
  return chars.join("");
}
function storage() {
  return _getInstance(browserLocalPersistence);
}
function persistenceKey(auth) {
  return _persistenceKeyName("authEvent", auth.config.apiKey, auth.name);
}
function parseJsonOrNull(json) {
  try {
    return JSON.parse(json);
  } catch (e) {
    return null;
  }
}
function _getDeepLinkFromCallback(url) {
  var params = searchParamsOrEmpty(url);
  var link = params["link"] ? decodeURIComponent(params["link"]) : void 0;
  var doubleDeepLink = searchParamsOrEmpty(link)["link"];
  var iOSDeepLink = params["deep_link_id"] ? decodeURIComponent(params["deep_link_id"]) : void 0;
  var iOSDoubleDeepLink = searchParamsOrEmpty(iOSDeepLink)["link"];
  return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
function searchParamsOrEmpty(url) {
  if (!(url === null || url === void 0 ? void 0 : url.includes("?"))) {
    return {};
  }
  var _a2 = url.split("?");
  _a2[0];
  var rest = _a2.slice(1);
  return querystringDecode(rest.join("?"));
}
var INITIAL_EVENT_TIMEOUT_MS = 500;
var CordovaPopupRedirectResolver = (
  /** @class */
  function() {
    function CordovaPopupRedirectResolver2() {
      this._redirectPersistence = browserSessionPersistence;
      this._shouldInitProactively = true;
      this.eventManagers = /* @__PURE__ */ new Map();
      this.originValidationPromises = {};
      this._completeRedirectFn = _getRedirectResult;
      this._overrideRedirectResult = _overrideRedirectResult;
    }
    CordovaPopupRedirectResolver2.prototype._initialize = function(auth) {
      return __awaiter(this, void 0, void 0, function() {
        var key, manager;
        return __generator(this, function(_a2) {
          key = auth._key();
          manager = this.eventManagers.get(key);
          if (!manager) {
            manager = new CordovaAuthEventManager(auth);
            this.eventManagers.set(key, manager);
            this.attachCallbackListeners(auth, manager);
          }
          return [2, manager];
        });
      });
    };
    CordovaPopupRedirectResolver2.prototype._openPopup = function(auth) {
      _fail(
        auth,
        "operation-not-supported-in-this-environment"
        /* AuthErrorCode.OPERATION_NOT_SUPPORTED */
      );
    };
    CordovaPopupRedirectResolver2.prototype._openRedirect = function(auth, provider, authType, eventId) {
      return __awaiter(this, void 0, void 0, function() {
        var manager, event, url, iabRef;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _checkCordovaConfiguration(auth);
              return [4, this._initialize(auth)];
            case 1:
              manager = _a2.sent();
              return [4, manager.initialized()];
            case 2:
              _a2.sent();
              manager.resetRedirect();
              _clearRedirectOutcomes();
              return [4, this._originValidation(auth)];
            case 3:
              _a2.sent();
              event = _generateNewEvent(auth, authType, eventId);
              return [4, _savePartialEvent(auth, event)];
            case 4:
              _a2.sent();
              return [4, _generateHandlerUrl(auth, event, provider)];
            case 5:
              url = _a2.sent();
              return [4, _performRedirect(url)];
            case 6:
              iabRef = _a2.sent();
              return [2, _waitForAppResume(auth, manager, iabRef)];
          }
        });
      });
    };
    CordovaPopupRedirectResolver2.prototype._isIframeWebStorageSupported = function(_auth, _cb) {
      throw new Error("Method not implemented.");
    };
    CordovaPopupRedirectResolver2.prototype._originValidation = function(auth) {
      var key = auth._key();
      if (!this.originValidationPromises[key]) {
        this.originValidationPromises[key] = _validateOrigin(auth);
      }
      return this.originValidationPromises[key];
    };
    CordovaPopupRedirectResolver2.prototype.attachCallbackListeners = function(auth, manager) {
      var _this = this;
      var _a2 = _cordovaWindow(), universalLinks = _a2.universalLinks, handleOpenURL = _a2.handleOpenURL, BuildInfo = _a2.BuildInfo;
      var noEventTimeout = setTimeout(function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                return [4, _getAndRemoveEvent(auth)];
              case 1:
                _a3.sent();
                manager.onEvent(generateNoEvent());
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, INITIAL_EVENT_TIMEOUT_MS);
      var universalLinksCb = function(eventData) {
        return __awaiter(_this, void 0, void 0, function() {
          var partialEvent, finalEvent;
          return __generator(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                clearTimeout(noEventTimeout);
                return [4, _getAndRemoveEvent(auth)];
              case 1:
                partialEvent = _a3.sent();
                finalEvent = null;
                if (partialEvent && (eventData === null || eventData === void 0 ? void 0 : eventData["url"])) {
                  finalEvent = _eventFromPartialAndUrl(partialEvent, eventData["url"]);
                }
                manager.onEvent(finalEvent || generateNoEvent());
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      if (typeof universalLinks !== "undefined" && typeof universalLinks.subscribe === "function") {
        universalLinks.subscribe(null, universalLinksCb);
      }
      var existingHandleOpenURL = handleOpenURL;
      var packagePrefix = "".concat(BuildInfo.packageName.toLowerCase(), "://");
      _cordovaWindow().handleOpenURL = function(url) {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a3) {
            if (url.toLowerCase().startsWith(packagePrefix)) {
              universalLinksCb({ url });
            }
            if (typeof existingHandleOpenURL === "function") {
              try {
                existingHandleOpenURL(url);
              } catch (e) {
                console.error(e);
              }
            }
            return [
              2
              /*return*/
            ];
          });
        });
      };
    };
    return CordovaPopupRedirectResolver2;
  }()
);
var cordovaPopupRedirectResolver = CordovaPopupRedirectResolver;
function generateNoEvent() {
  return {
    type: "unknown",
    eventId: null,
    sessionId: null,
    urlResponse: null,
    postBody: null,
    tenantId: null,
    error: _createError(
      "no-auth-event"
      /* AuthErrorCode.NO_AUTH_EVENT */
    )
  };
}

// node_modules/@firebase/auth/dist/cordova/index.js
function signInWithRedirect(auth, provider, resolver) {
  return _signInWithRedirect(auth, provider, resolver);
}
function reauthenticateWithRedirect(user, provider, resolver) {
  return _reauthenticateWithRedirect(user, provider, resolver);
}
function linkWithRedirect(user, provider, resolver) {
  return _linkWithRedirect(user, provider, resolver);
}
function getAuth(app) {
  if (app === void 0) {
    app = getApp();
  }
  var provider = _getProvider(app, "auth");
  if (provider.isInitialized()) {
    return provider.getImmediate();
  }
  return initializeAuth(app, {
    persistence: indexedDBLocalPersistence,
    popupRedirectResolver: cordovaPopupRedirectResolver
  });
}
registerAuth(
  "Cordova"
  /* ClientPlatform.CORDOVA */
);
export {
  ActionCodeOperation,
  ActionCodeURL,
  AuthCredential,
  AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY as AuthErrorCodes,
  EmailAuthCredential,
  EmailAuthProvider,
  FacebookAuthProvider,
  FactorId,
  GithubAuthProvider,
  GoogleAuthProvider,
  OAuthCredential,
  OAuthProvider,
  OperationType,
  PhoneAuthCredential,
  ProviderId,
  SAMLAuthProvider,
  SignInMethod,
  TwitterAuthProvider,
  applyActionCode,
  beforeAuthStateChanged,
  browserLocalPersistence,
  browserSessionPersistence,
  checkActionCode,
  confirmPasswordReset,
  connectAuthEmulator,
  cordovaPopupRedirectResolver,
  createUserWithEmailAndPassword,
  debugErrorMap,
  deleteUser,
  fetchSignInMethodsForEmail,
  getAdditionalUserInfo,
  getAuth,
  getIdToken,
  getIdTokenResult,
  getMultiFactorResolver,
  getRedirectResult,
  inMemoryPersistence,
  indexedDBLocalPersistence,
  initializeAuth,
  initializeRecaptchaConfig,
  isSignInWithEmailLink,
  linkWithCredential,
  linkWithRedirect,
  multiFactor,
  onAuthStateChanged,
  onIdTokenChanged,
  parseActionCodeURL,
  prodErrorMap,
  reauthenticateWithCredential,
  reauthenticateWithRedirect,
  reload,
  revokeAccessToken,
  sendEmailVerification,
  sendPasswordResetEmail,
  sendSignInLinkToEmail,
  setPersistence,
  signInAnonymously,
  signInWithCredential,
  signInWithCustomToken,
  signInWithEmailAndPassword,
  signInWithEmailLink,
  signInWithRedirect,
  signOut,
  unlink,
  updateCurrentUser,
  updateEmail,
  updatePassword,
  updateProfile,
  useDeviceLanguage,
  validatePassword,
  verifyBeforeUpdateEmail,
  verifyPasswordResetCode
};
/*! Bundled license information:

@firebase/auth/dist/cordova/popup_redirect-106f885f.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/auth/dist/cordova/popup_redirect-106f885f.js:
  (**
   * @license
   * Copyright 2020 Google LLC.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/auth/dist/cordova/popup_redirect-106f885f.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/auth/dist/cordova/popup_redirect-106f885f.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/auth/dist/cordova/popup_redirect-106f885f.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2023 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/auth/dist/cordova/popup_redirect-106f885f.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/auth/dist/cordova/popup_redirect-106f885f.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/auth/dist/cordova/popup_redirect-106f885f.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/auth/dist/cordova/popup_redirect-106f885f.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/auth/dist/cordova/index.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=firebase_auth_cordova.js.map
